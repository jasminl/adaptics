<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">   
 <meta>
  <!-- Stylesheets -->
  <link href="../web.css" type="text/css" rel="stylesheet"></link>
  <title>VLFeat - C API</title>
  
  
  <!-- Scripts-->
 
 </meta>
 
 <!-- Body Start -->
 <body>
  <div id="header">
   <!-- Google CSE Search Box Begins -->
   <form action=" http://www.vlfeat.org/search.html" method="get" id="cse-search-box" enctype="application/x-www-form-urlencoded">
    <div>
     <input type="hidden" name="cx" value="003215582122030917471:oq23albfeam"></input>
     <input type="hidden" name="cof" value="FORID:11"></input>
     <input type="hidden" name="ie" value="UTF-8"></input>
     <input type="text" name="q" size="31"></input>
     <input type="submit" name="sa" value="Search"></input>
    </div>
   </form>
   <script src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" xml:space="preserve" type="text/javascript"></script>
   <!-- Google CSE Search Box Ends -->
   <h1>VLFeat.org</h1>
  </div>
  <div id="headbanner">
  C API
  </div>
  <div id="pagebody">
   <div id="sidebar"> <!-- Navigation Start -->
   <ul>
<li><a href="../index.html">Home</a>
</li>
<li><a href="../download.html">Download</a>
</li>
<li><a href="index.html" class='active' >C API</a>
</li>
<li><a href="../mdoc/mdoc.html">Matlab API</a>
</li>
<li><a href="../man/man.html">Man pages</a>
</li>
<li><a href="../overview/tut.html">Tutorials</a>
</li>
</ul>

   </div> <!-- sidebar -->
   <div id="content">
   
   <div class="doxygen">
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>mathop.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Andrea Vedaldi </dd></dl>

<p>Definition in file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>
<code>#include &quot;<a class="el" href="generic_8h-source.html">generic.h</a>&quot;</code><br>

<p>
<a href="mathop_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ui16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#86d016e43f6bd34474539f17862445c3">VL_FAST_SQRT_UI</a> (<a class="el" href="host_8h.html#38fbd9a3cf53dfc9a5650c38497b7d35">vl_uint8</a>, ui8) float vl_dist_l2_f(float *dist</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Auto distances.  <a href="#86d016e43f6bd34474539f17862445c3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5103e2bf416806fb511feaa8ee96328f"></a><!-- doxytag: member="mathop.h::VL_LOG_OF_2" ref="5103e2bf416806fb511feaa8ee96328f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#5103e2bf416806fb511feaa8ee96328f">VL_LOG_OF_2</a>&nbsp;&nbsp;&nbsp;0.693147180559945</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logarithm of 2 (math constant). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="19d43a5e0c355df553ebe825208a4cc1"></a><!-- doxytag: member="mathop.h::VL_PI" ref="19d43a5e0c355df553ebe825208a4cc1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1">VL_PI</a>&nbsp;&nbsp;&nbsp;3.141592653589793</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pi (math constant). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#8088f3da04d6bce27544adaa6da948ca">VL_EPSILON_F</a>&nbsp;&nbsp;&nbsp;1.19209290E-07F</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IEEE single precision epsilon (math constant).  <a href="#8088f3da04d6bce27544adaa6da948ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#a2d957b08ce16011fc3827c270cd2664">VL_EPSILON_D</a>&nbsp;&nbsp;&nbsp;2.220446049250313e-16</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IEEE double precision epsilon (math constant).  <a href="#a2d957b08ce16011fc3827c270cd2664"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fcbfd66dfa72bf495e08e1d622d6da0e"></a><!-- doxytag: member="mathop.h::VL_NAN_F" ref="fcbfd66dfa72bf495e08e1d622d6da0e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#fcbfd66dfa72bf495e08e1d622d6da0e">VL_NAN_F</a>&nbsp;&nbsp;&nbsp;(vl_nan_f.value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IEEE single precision NaN (not signaling). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7c8e51b4132fa5072a31ec38770e22c6"></a><!-- doxytag: member="mathop.h::VL_INFINITY_F" ref="7c8e51b4132fa5072a31ec38770e22c6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#7c8e51b4132fa5072a31ec38770e22c6">VL_INFINITY_F</a>&nbsp;&nbsp;&nbsp;(vl_infinity_f.value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IEEE single precision positive infinity (not signaling). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f9df65fc71880e96e21e93e3abfd99c"></a><!-- doxytag: member="mathop.h::VL_NAN_D" ref="3f9df65fc71880e96e21e93e3abfd99c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#3f9df65fc71880e96e21e93e3abfd99c">VL_NAN_D</a>&nbsp;&nbsp;&nbsp;(vl_nan_d.value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IEEE double precision NaN (not signaling). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9eb876cf62894be62a2467db9db0bb03"></a><!-- doxytag: member="mathop.h::VL_INFINITY_D" ref="9eb876cf62894be62a2467db9db0bb03" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#9eb876cf62894be62a2467db9db0bb03">VL_INFINITY_D</a>&nbsp;&nbsp;&nbsp;(vl_infinity_d.value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IEEE double precision positive infinity (not signaling). <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#779371154b6f6c1a0f9bf51ad9afcd07">vl_mod_2pi_f</a> (float x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>mod(x, 2 * VL_PI)</code>.  <a href="#779371154b6f6c1a0f9bf51ad9afcd07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#b3a92ebb19b74de0f5853016c70fe7b0">vl_mod_2pi_d</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>mod(x, 2 * VL_PI)</code>.  <a href="#b3a92ebb19b74de0f5853016c70fe7b0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52">vl_floor_f</a> (float x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>(int) floor(x)</code>.  <a href="#0a641bb83f3aa7db107a51f63a534b52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac">vl_floor_d</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>(int) floor(x)</code>.  <a href="#48bb7ee0a0b8f26c1ddcc8e9821f36ac"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084">vl_abs_f</a> (float x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>abs(x)</code>.  <a href="#c661df89e4bbb2730b3b5a8d15713084"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8">vl_abs_d</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>abs(x)</code>.  <a href="#b54b15a314843c27e7333e2fd05c0eb8"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#83b506c15839a1b6b07ed81e20f2906e">vl_fast_atan2_f</a> (float y, float x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>atan2</code> approximation.  <a href="#83b506c15839a1b6b07ed81e20f2906e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#78e511bf11055a29ef1d3fb9c1b74335">vl_fast_atan2_d</a> (double y, double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>atan2</code> approximation.  <a href="#78e511bf11055a29ef1d3fb9c1b74335"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#d9c702db6c4e7f2fc20d8e2f4b989032">vl_fast_resqrt_f</a> (float x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>resqrt</code> approximation.  <a href="#d9c702db6c4e7f2fc20d8e2f4b989032"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#12d10d044fd75e618b83d4c390071e78">vl_fast_resqrt_d</a> (double x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>resqrt</code> approximation.  <a href="#12d10d044fd75e618b83d4c390071e78"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#fd17414c0bd6edce9280378201a24847">vl_fast_sqrt_f</a> (float x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>sqrt</code> approximation.  <a href="#fd17414c0bd6edce9280378201a24847"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#70b8ce69987f6aff1228f929ddf9ad26">vl_fast_sqrt_d</a> (float x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>sqrt</code> approximation.  <a href="#70b8ce69987f6aff1228f929ddf9ad26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE <a class="el" href="host_8h.html#eb7c862765448a70017105efa4d25e7a">vl_uint32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#39094d72320eff7aa86f69317732e3cc">vl_fast_sqrt_ui32</a> (<a class="el" href="host_8h.html#eb7c862765448a70017105efa4d25e7a">vl_uint32</a> x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>sqrt</code> approximation.  <a href="#39094d72320eff7aa86f69317732e3cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE <a class="el" href="host_8h.html#b2275d6c7bf6fc027151d11072b45f03">vl_uint16</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#43c9d07619e842e4e6804a7fc16c2b01">vl_fast_sqrt_ui16</a> (<a class="el" href="host_8h.html#b2275d6c7bf6fc027151d11072b45f03">vl_uint16</a> x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>sqrt</code> approximation.  <a href="#43c9d07619e842e4e6804a7fc16c2b01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE <a class="el" href="host_8h.html#38fbd9a3cf53dfc9a5650c38497b7d35">vl_uint8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="mathop_8h.html#5a6bc29fcc3ac5a673d7d4c5191cf104">vl_fast_sqrt_ui8</a> (<a class="el" href="host_8h.html#38fbd9a3cf53dfc9a5650c38497b7d35">vl_uint8</a> x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast <code>sqrt</code> approximation.  <a href="#5a6bc29fcc3ac5a673d7d4c5191cf104"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a2d957b08ce16011fc3827c270cd2664"></a><!-- doxytag: member="mathop.h::VL_EPSILON_D" ref="a2d957b08ce16011fc3827c270cd2664" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL_EPSILON_D&nbsp;&nbsp;&nbsp;2.220446049250313e-16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>1.0 + VL_EPSILON_D</code> is the smallest representable double precision number greater than <code>1.0</code>. Numerically, <a class="el" href="mathop_8h.html#a2d957b08ce16011fc3827c270cd2664" title="IEEE double precision epsilon (math constant).">VL_EPSILON_D</a> is equal to <img class="formulaInl" alt="$ 2^{-52} $" src="form_75.png">. 
<p>Definition at line <a class="el" href="mathop_8h-source.html#l00039">39</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>Referenced by <a class="el" href="mathop_8h-source.html#l00227">vl_fast_atan2_d()</a>, and <a class="el" href="sift_8c-source.html#l01712">vl_sift_calc_raw_descriptor()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8088f3da04d6bce27544adaa6da948ca"></a><!-- doxytag: member="mathop.h::VL_EPSILON_F" ref="8088f3da04d6bce27544adaa6da948ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VL_EPSILON_F&nbsp;&nbsp;&nbsp;1.19209290E-07F          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>1.0F + VL_EPSILON_F</code> is the smallest representable single precision number greater than <code>1.0F</code>. Numerically, <a class="el" href="mathop_8h.html#8088f3da04d6bce27544adaa6da948ca" title="IEEE single precision epsilon (math constant).">VL_EPSILON_F</a> is equal to <img class="formulaInl" alt="$ 2^{-23} $" src="form_74.png">. 
<p>Definition at line <a class="el" href="mathop_8h-source.html#l00031">31</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>Referenced by <a class="el" href="dsift_8c-source.html#l00280">_vl_dsift_normalize_histogram()</a>, <a class="el" href="sift_8c-source.html#l01662">normalize_histogram()</a>, <a class="el" href="mathop_8h-source.html#l00207">vl_fast_atan2_f()</a>, and <a class="el" href="pgm_8c-source.html#l00553">vl_pgm_write_f()</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="b54b15a314843c27e7333e2fd05c0eb8"></a><!-- doxytag: member="mathop.h::vl_abs_d" ref="b54b15a314843c27e7333e2fd05c0eb8" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE double vl_abs_d           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>abs(x)</code> </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00162">162</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>Referenced by <a class="el" href="mathop_8h-source.html#l00227">vl_fast_atan2_d()</a>, and <a class="el" href="sift_8c-source.html#l01111">vl_sift_detect()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c661df89e4bbb2730b3b5a8d15713084"></a><!-- doxytag: member="mathop.h::vl_abs_f" ref="c661df89e4bbb2730b3b5a8d15713084" args="(float x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE float vl_abs_f           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>abs(x)</code> </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00155">155</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>Referenced by <a class="el" href="mathop_8h-source.html#l00207">vl_fast_atan2_f()</a>, <a class="el" href="sift_8c-source.html#l01881">vl_sift_calc_keypoint_descriptor()</a>, and <a class="el" href="sift_8c-source.html#l01712">vl_sift_calc_raw_descriptor()</a>.</p>

</div>
</div><p>
<a class="anchor" name="78e511bf11055a29ef1d3fb9c1b74335"></a><!-- doxytag: member="mathop.h::vl_fast_atan2_d" ref="78e511bf11055a29ef1d3fb9c1b74335" args="(double y, double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE double vl_fast_atan2_d           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>argument. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument.</td></tr>
  </table>
</dl>
The function computes a relatively rough but fast approximation of <code>atan2(y,x)</code>.<p>
<dl class="user" compact><dt><b>Algorithm</b></dt><dd></dd></dl>
The algorithm approximates the function <img class="formulaInl" alt="$ f(r)=atan((1-r)/(1+r)) $" src="form_76.png">, <img class="formulaInl" alt="$ r \in [-1,1] $" src="form_77.png"> with a third order polynomial <img class="formulaInl" alt="$ f(r)=c_0 + c_1 r + c_2 r^2 + c_3 r^3 $" src="form_78.png">. To fit the polynomial we impose the constraints<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f(+1) &amp;=&amp; c_0 + c_1 + c_2 + c_3 = atan(0) = 0,\\ f(-1) &amp;=&amp; c_0 - c_1 + c_2 - c_3 = atan(\infty) = \pi/2,\\ f(0) &amp;=&amp; c_0 = atan(1) = \pi/4. \end{eqnarray*}" src="form_79.png">
<p>
<p>
The last degree of freedom is fixed by minimizing the <img class="formulaInl" alt="$ l^{\infty} $" src="form_80.png"> error, which yields<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ c_0=\pi/4, \quad c_1=-0.9675, \quad c_2=0, \quad c_3=0.1821, \]" src="form_81.png">
<p>
<p>
with maximum error of 0.0061 radians at 0.35 degrees.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximation of <code>atan2(y,x)</code>. </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00227">227</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>References <a class="el" href="mathop_8h-source.html#l00162">vl_abs_d()</a>, <a class="el" href="mathop_8h-source.html#l00039">VL_EPSILON_D</a>, and <a class="el" href="mathop_8h-source.html#l00022">VL_PI</a>.</p>

</div>
</div><p>
<a class="anchor" name="83b506c15839a1b6b07ed81e20f2906e"></a><!-- doxytag: member="mathop.h::vl_fast_atan2_f" ref="83b506c15839a1b6b07ed81e20f2906e" args="(float y, float x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE float vl_fast_atan2_f           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>argument. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument.</td></tr>
  </table>
</dl>
The function computes a relatively rough but fast approximation of <code>atan2(y,x)</code>.<p>
<dl class="user" compact><dt><b>Algorithm</b></dt><dd></dd></dl>
The algorithm approximates the function <img class="formulaInl" alt="$ f(r)=atan((1-r)/(1+r)) $" src="form_76.png">, <img class="formulaInl" alt="$ r \in [-1,1] $" src="form_77.png"> with a third order polynomial <img class="formulaInl" alt="$ f(r)=c_0 + c_1 r + c_2 r^2 + c_3 r^3 $" src="form_78.png">. To fit the polynomial we impose the constraints<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} f(+1) &amp;=&amp; c_0 + c_1 + c_2 + c_3 = atan(0) = 0,\\ f(-1) &amp;=&amp; c_0 - c_1 + c_2 - c_3 = atan(\infty) = \pi/2,\\ f(0) &amp;=&amp; c_0 = atan(1) = \pi/4. \end{eqnarray*}" src="form_79.png">
<p>
<p>
The last degree of freedom is fixed by minimizing the <img class="formulaInl" alt="$ l^{\infty} $" src="form_80.png"> error, which yields<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ c_0=\pi/4, \quad c_1=-0.9675, \quad c_2=0, \quad c_3=0.1821, \]" src="form_81.png">
<p>
<p>
with maximum error of 0.0061 radians at 0.35 degrees.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximation of <code>atan2(y,x)</code>. </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00207">207</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>References <a class="el" href="mathop_8h-source.html#l00155">vl_abs_f()</a>, <a class="el" href="mathop_8h-source.html#l00031">VL_EPSILON_F</a>, and <a class="el" href="mathop_8h-source.html#l00022">VL_PI</a>.</p>

<p>Referenced by <a class="el" href="dsift_8c-source.html#l00620">vl_dsift_process()</a>.</p>

</div>
</div><p>
<a class="anchor" name="12d10d044fd75e618b83d4c390071e78"></a><!-- doxytag: member="mathop.h::vl_fast_resqrt_d" ref="12d10d044fd75e618b83d4c390071e78" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE double vl_fast_resqrt_d           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument.</td></tr>
  </table>
</dl>
The function quickly computes an approximation of <img class="formulaInl" alt="$ x^{-1/2} $" src="form_82.png">.<p>
<dl class="user" compact><dt><b>Algorithm</b></dt><dd></dd></dl>
The goal is to compute <img class="formulaInl" alt="$ y = x^{-1/2} $" src="form_83.png">, which we do by finding the solution of <img class="formulaInl" alt="$ 0 = f(y) = y^{-2} - x$" src="form_84.png"> by two Newton steps. Each Newton iteration is given by<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ y \leftarrow y - \frac{f(y)}{\dot f(y)} = y + \frac{1}{2} (y-xy^3) = \frac{y}{2} \left( 3 - xy^2 \right) \]" src="form_85.png">
<p>
<p>
which yields a simple polynomial update rule.<p>
The clever bit (attributed to either J. Carmack or G. Tarolli) is the way an initial guess <img class="formulaInl" alt="$ y \approx x^{-1/2} $" src="form_86.png"> is chosen.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.lomont.org/Math/Papers/2003/InvSqrt.pdf">Inverse Sqare Root</a>.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximation of <code>resqrt(x)</code>. </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00304">304</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>Referenced by <a class="el" href="mathop_8h-source.html#l00389">vl_fast_sqrt_d()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d9c702db6c4e7f2fc20d8e2f4b989032"></a><!-- doxytag: member="mathop.h::vl_fast_resqrt_f" ref="d9c702db6c4e7f2fc20d8e2f4b989032" args="(float x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE float vl_fast_resqrt_f           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument.</td></tr>
  </table>
</dl>
The function quickly computes an approximation of <img class="formulaInl" alt="$ x^{-1/2} $" src="form_82.png">.<p>
<dl class="user" compact><dt><b>Algorithm</b></dt><dd></dd></dl>
The goal is to compute <img class="formulaInl" alt="$ y = x^{-1/2} $" src="form_83.png">, which we do by finding the solution of <img class="formulaInl" alt="$ 0 = f(y) = y^{-2} - x$" src="form_84.png"> by two Newton steps. Each Newton iteration is given by<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ y \leftarrow y - \frac{f(y)}{\dot f(y)} = y + \frac{1}{2} (y-xy^3) = \frac{y}{2} \left( 3 - xy^2 \right) \]" src="form_85.png">
<p>
<p>
which yields a simple polynomial update rule.<p>
The clever bit (attributed to either J. Carmack or G. Tarolli) is the way an initial guess <img class="formulaInl" alt="$ y \approx x^{-1/2} $" src="form_86.png"> is chosen.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.lomont.org/Math/Papers/2003/InvSqrt.pdf">Inverse Sqare Root</a>.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximation of <code>resqrt(x)</code>. </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00279">279</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>Referenced by <a class="el" href="mathop_8h-source.html#l00382">vl_fast_sqrt_f()</a>.</p>

</div>
</div><p>
<a class="anchor" name="70b8ce69987f6aff1228f929ddf9ad26"></a><!-- doxytag: member="mathop.h::vl_fast_sqrt_d" ref="70b8ce69987f6aff1228f929ddf9ad26" args="(float x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE double vl_fast_sqrt_d           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument.</td></tr>
  </table>
</dl>
The function computes a fast approximation of <code>sqrt(x)</code>.<p>
<dl class="user" compact><dt><b>Floating-point algorithm</b></dt><dd></dd></dl>
For the floating point cases, the function uses <a class="el" href="mathop_8h.html#d9c702db6c4e7f2fc20d8e2f4b989032" title="Fast resqrt approximation.">vl_fast_resqrt_f</a> (or <a class="el" href="mathop_8h.html#12d10d044fd75e618b83d4c390071e78" title="Fast resqrt approximation.">vl_fast_resqrt_d</a>) to compute <code>x * vl_fast_resqrt_f(x)</code>.<p>
<dl class="user" compact><dt><b>Integer algorithm</b></dt><dd></dd></dl>
We seek for the largest integer <em>y</em> such that <img class="formulaInl" alt="$ y^2 \leq x $" src="form_87.png">. Write <img class="formulaInl" alt="$ y = w + b_k 2^k + z $" src="form_88.png"> where the binary expansion of the various variable is<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = \sum_{i=0}^{n-1} 2^i a_i, \qquad w = \sum_{i=k+1}^{m-1} 2^i b_i, \qquad z = \sum_{i=0}^{k-1} 2^i b_i. \]" src="form_89.png">
<p>
<p>
Assume <em>w</em> known. Expanding the square and using the fact that <img class="formulaInl" alt="$ b_k^2=b_k $" src="form_90.png">, we obtain the following constraint for <img class="formulaInl" alt="$ b_k $" src="form_91.png"> and <em>z:</em> <p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x - w^2 \geq 2^k ( 2 w + 2^k ) b_k + z (z + 2wz + 2^{k+1}z b_k) \]" src="form_92.png">
<p>
<p>
A necessary condition for <img class="formulaInl" alt="$ b_k = 1 $" src="form_93.png"> is that this equation is satisfied for <img class="formulaInl" alt="$ z = 0 $" src="form_94.png"> (as the second term is always non-negative). In fact, this condition is also sufficient, since we are looking for the <em>largest</em> solution <em>y</em>.<p>
This yields the following iterative algorithm. First, note that if <em>x</em> is stored in <em>n</em> bits, where <em>n</em> is even, then the integer square root does not require more than <img class="formulaInl" alt="$ m = n / 2 $" src="form_95.png"> bit to be stored. Thus initially, <img class="formulaInl" alt="$ w = 0 $" src="form_96.png"> and <img class="formulaInl" alt="$ k = m - 1 = n/2 - 1 $" src="form_97.png">. Then, at each iteration the equation is tested, determining <img class="formulaInl" alt="$ b_{m-1}, b_{m-2}, ... $" src="form_98.png"> in this order.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximation of <code>sqrt(x)</code>. </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00389">389</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>References <a class="el" href="mathop_8h-source.html#l00304">vl_fast_resqrt_d()</a>.</p>

</div>
</div><p>
<a class="anchor" name="fd17414c0bd6edce9280378201a24847"></a><!-- doxytag: member="mathop.h::vl_fast_sqrt_f" ref="fd17414c0bd6edce9280378201a24847" args="(float x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE float vl_fast_sqrt_f           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument.</td></tr>
  </table>
</dl>
The function computes a fast approximation of <code>sqrt(x)</code>.<p>
<dl class="user" compact><dt><b>Floating-point algorithm</b></dt><dd></dd></dl>
For the floating point cases, the function uses <a class="el" href="mathop_8h.html#d9c702db6c4e7f2fc20d8e2f4b989032" title="Fast resqrt approximation.">vl_fast_resqrt_f</a> (or <a class="el" href="mathop_8h.html#12d10d044fd75e618b83d4c390071e78" title="Fast resqrt approximation.">vl_fast_resqrt_d</a>) to compute <code>x * vl_fast_resqrt_f(x)</code>.<p>
<dl class="user" compact><dt><b>Integer algorithm</b></dt><dd></dd></dl>
We seek for the largest integer <em>y</em> such that <img class="formulaInl" alt="$ y^2 \leq x $" src="form_87.png">. Write <img class="formulaInl" alt="$ y = w + b_k 2^k + z $" src="form_88.png"> where the binary expansion of the various variable is<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = \sum_{i=0}^{n-1} 2^i a_i, \qquad w = \sum_{i=k+1}^{m-1} 2^i b_i, \qquad z = \sum_{i=0}^{k-1} 2^i b_i. \]" src="form_89.png">
<p>
<p>
Assume <em>w</em> known. Expanding the square and using the fact that <img class="formulaInl" alt="$ b_k^2=b_k $" src="form_90.png">, we obtain the following constraint for <img class="formulaInl" alt="$ b_k $" src="form_91.png"> and <em>z:</em> <p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x - w^2 \geq 2^k ( 2 w + 2^k ) b_k + z (z + 2wz + 2^{k+1}z b_k) \]" src="form_92.png">
<p>
<p>
A necessary condition for <img class="formulaInl" alt="$ b_k = 1 $" src="form_93.png"> is that this equation is satisfied for <img class="formulaInl" alt="$ z = 0 $" src="form_94.png"> (as the second term is always non-negative). In fact, this condition is also sufficient, since we are looking for the <em>largest</em> solution <em>y</em>.<p>
This yields the following iterative algorithm. First, note that if <em>x</em> is stored in <em>n</em> bits, where <em>n</em> is even, then the integer square root does not require more than <img class="formulaInl" alt="$ m = n / 2 $" src="form_95.png"> bit to be stored. Thus initially, <img class="formulaInl" alt="$ w = 0 $" src="form_96.png"> and <img class="formulaInl" alt="$ k = m - 1 = n/2 - 1 $" src="form_97.png">. Then, at each iteration the equation is tested, determining <img class="formulaInl" alt="$ b_{m-1}, b_{m-2}, ... $" src="form_98.png"> in this order.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximation of <code>sqrt(x)</code>. </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00382">382</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>References <a class="el" href="mathop_8h-source.html#l00279">vl_fast_resqrt_f()</a>.</p>

<p>Referenced by <a class="el" href="dsift_8c-source.html#l00280">_vl_dsift_normalize_histogram()</a>, <a class="el" href="sift_8c-source.html#l01662">normalize_histogram()</a>, and <a class="el" href="dsift_8c-source.html#l00620">vl_dsift_process()</a>.</p>

</div>
</div><p>
<a class="anchor" name="86d016e43f6bd34474539f17862445c3"></a><!-- doxytag: member="mathop.h::VL_FAST_SQRT_UI" ref="86d016e43f6bd34474539f17862445c3" args="(vl_uint8, ui8) float vl_dist_l2_f(float *dist" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ui16 VL_FAST_SQRT_UI           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="host_8h.html#38fbd9a3cf53dfc9a5650c38497b7d35">vl_uint8</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ui8&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dist</em>&nbsp;</td><td>pointer to the distance matrix (out). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>M</em>&nbsp;</td><td>number of dimensions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NX</em>&nbsp;</td><td>number of data points in X. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NY</em>&nbsp;</td><td>number of data points in Y. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>X</em>&nbsp;</td><td>first data set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Y</em>&nbsp;</td><td>second data set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="43c9d07619e842e4e6804a7fc16c2b01"></a><!-- doxytag: member="mathop.h::vl_fast_sqrt_ui16" ref="43c9d07619e842e4e6804a7fc16c2b01" args="(vl_uint16 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE <a class="el" href="host_8h.html#b2275d6c7bf6fc027151d11072b45f03">vl_uint16</a> vl_fast_sqrt_ui16           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="host_8h.html#b2275d6c7bf6fc027151d11072b45f03">vl_uint16</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument.</td></tr>
  </table>
</dl>
The function computes a fast approximation of <code>sqrt(x)</code>.<p>
<dl class="user" compact><dt><b>Floating-point algorithm</b></dt><dd></dd></dl>
For the floating point cases, the function uses <a class="el" href="mathop_8h.html#d9c702db6c4e7f2fc20d8e2f4b989032" title="Fast resqrt approximation.">vl_fast_resqrt_f</a> (or <a class="el" href="mathop_8h.html#12d10d044fd75e618b83d4c390071e78" title="Fast resqrt approximation.">vl_fast_resqrt_d</a>) to compute <code>x * vl_fast_resqrt_f(x)</code>.<p>
<dl class="user" compact><dt><b>Integer algorithm</b></dt><dd></dd></dl>
We seek for the largest integer <em>y</em> such that <img class="formulaInl" alt="$ y^2 \leq x $" src="form_87.png">. Write <img class="formulaInl" alt="$ y = w + b_k 2^k + z $" src="form_88.png"> where the binary expansion of the various variable is<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = \sum_{i=0}^{n-1} 2^i a_i, \qquad w = \sum_{i=k+1}^{m-1} 2^i b_i, \qquad z = \sum_{i=0}^{k-1} 2^i b_i. \]" src="form_89.png">
<p>
<p>
Assume <em>w</em> known. Expanding the square and using the fact that <img class="formulaInl" alt="$ b_k^2=b_k $" src="form_90.png">, we obtain the following constraint for <img class="formulaInl" alt="$ b_k $" src="form_91.png"> and <em>z:</em> <p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x - w^2 \geq 2^k ( 2 w + 2^k ) b_k + z (z + 2wz + 2^{k+1}z b_k) \]" src="form_92.png">
<p>
<p>
A necessary condition for <img class="formulaInl" alt="$ b_k = 1 $" src="form_93.png"> is that this equation is satisfied for <img class="formulaInl" alt="$ z = 0 $" src="form_94.png"> (as the second term is always non-negative). In fact, this condition is also sufficient, since we are looking for the <em>largest</em> solution <em>y</em>.<p>
This yields the following iterative algorithm. First, note that if <em>x</em> is stored in <em>n</em> bits, where <em>n</em> is even, then the integer square root does not require more than <img class="formulaInl" alt="$ m = n / 2 $" src="form_95.png"> bit to be stored. Thus initially, <img class="formulaInl" alt="$ w = 0 $" src="form_96.png"> and <img class="formulaInl" alt="$ k = m - 1 = n/2 - 1 $" src="form_97.png">. Then, at each iteration the equation is tested, determining <img class="formulaInl" alt="$ b_{m-1}, b_{m-2}, ... $" src="form_98.png"> in this order.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximation of <code>sqrt(x)</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="39094d72320eff7aa86f69317732e3cc"></a><!-- doxytag: member="mathop.h::vl_fast_sqrt_ui32" ref="39094d72320eff7aa86f69317732e3cc" args="(vl_uint32 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE <a class="el" href="host_8h.html#eb7c862765448a70017105efa4d25e7a">vl_uint32</a> vl_fast_sqrt_ui32           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="host_8h.html#eb7c862765448a70017105efa4d25e7a">vl_uint32</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument.</td></tr>
  </table>
</dl>
The function computes a fast approximation of <code>sqrt(x)</code>.<p>
<dl class="user" compact><dt><b>Floating-point algorithm</b></dt><dd></dd></dl>
For the floating point cases, the function uses <a class="el" href="mathop_8h.html#d9c702db6c4e7f2fc20d8e2f4b989032" title="Fast resqrt approximation.">vl_fast_resqrt_f</a> (or <a class="el" href="mathop_8h.html#12d10d044fd75e618b83d4c390071e78" title="Fast resqrt approximation.">vl_fast_resqrt_d</a>) to compute <code>x * vl_fast_resqrt_f(x)</code>.<p>
<dl class="user" compact><dt><b>Integer algorithm</b></dt><dd></dd></dl>
We seek for the largest integer <em>y</em> such that <img class="formulaInl" alt="$ y^2 \leq x $" src="form_87.png">. Write <img class="formulaInl" alt="$ y = w + b_k 2^k + z $" src="form_88.png"> where the binary expansion of the various variable is<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = \sum_{i=0}^{n-1} 2^i a_i, \qquad w = \sum_{i=k+1}^{m-1} 2^i b_i, \qquad z = \sum_{i=0}^{k-1} 2^i b_i. \]" src="form_89.png">
<p>
<p>
Assume <em>w</em> known. Expanding the square and using the fact that <img class="formulaInl" alt="$ b_k^2=b_k $" src="form_90.png">, we obtain the following constraint for <img class="formulaInl" alt="$ b_k $" src="form_91.png"> and <em>z:</em> <p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x - w^2 \geq 2^k ( 2 w + 2^k ) b_k + z (z + 2wz + 2^{k+1}z b_k) \]" src="form_92.png">
<p>
<p>
A necessary condition for <img class="formulaInl" alt="$ b_k = 1 $" src="form_93.png"> is that this equation is satisfied for <img class="formulaInl" alt="$ z = 0 $" src="form_94.png"> (as the second term is always non-negative). In fact, this condition is also sufficient, since we are looking for the <em>largest</em> solution <em>y</em>.<p>
This yields the following iterative algorithm. First, note that if <em>x</em> is stored in <em>n</em> bits, where <em>n</em> is even, then the integer square root does not require more than <img class="formulaInl" alt="$ m = n / 2 $" src="form_95.png"> bit to be stored. Thus initially, <img class="formulaInl" alt="$ w = 0 $" src="form_96.png"> and <img class="formulaInl" alt="$ k = m - 1 = n/2 - 1 $" src="form_97.png">. Then, at each iteration the equation is tested, determining <img class="formulaInl" alt="$ b_{m-1}, b_{m-2}, ... $" src="form_98.png"> in this order.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximation of <code>sqrt(x)</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a6bc29fcc3ac5a673d7d4c5191cf104"></a><!-- doxytag: member="mathop.h::vl_fast_sqrt_ui8" ref="5a6bc29fcc3ac5a673d7d4c5191cf104" args="(vl_uint8 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE <a class="el" href="host_8h.html#38fbd9a3cf53dfc9a5650c38497b7d35">vl_uint8</a> vl_fast_sqrt_ui8           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="host_8h.html#38fbd9a3cf53dfc9a5650c38497b7d35">vl_uint8</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument.</td></tr>
  </table>
</dl>
The function computes a fast approximation of <code>sqrt(x)</code>.<p>
<dl class="user" compact><dt><b>Floating-point algorithm</b></dt><dd></dd></dl>
For the floating point cases, the function uses <a class="el" href="mathop_8h.html#d9c702db6c4e7f2fc20d8e2f4b989032" title="Fast resqrt approximation.">vl_fast_resqrt_f</a> (or <a class="el" href="mathop_8h.html#12d10d044fd75e618b83d4c390071e78" title="Fast resqrt approximation.">vl_fast_resqrt_d</a>) to compute <code>x * vl_fast_resqrt_f(x)</code>.<p>
<dl class="user" compact><dt><b>Integer algorithm</b></dt><dd></dd></dl>
We seek for the largest integer <em>y</em> such that <img class="formulaInl" alt="$ y^2 \leq x $" src="form_87.png">. Write <img class="formulaInl" alt="$ y = w + b_k 2^k + z $" src="form_88.png"> where the binary expansion of the various variable is<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x = \sum_{i=0}^{n-1} 2^i a_i, \qquad w = \sum_{i=k+1}^{m-1} 2^i b_i, \qquad z = \sum_{i=0}^{k-1} 2^i b_i. \]" src="form_89.png">
<p>
<p>
Assume <em>w</em> known. Expanding the square and using the fact that <img class="formulaInl" alt="$ b_k^2=b_k $" src="form_90.png">, we obtain the following constraint for <img class="formulaInl" alt="$ b_k $" src="form_91.png"> and <em>z:</em> <p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x - w^2 \geq 2^k ( 2 w + 2^k ) b_k + z (z + 2wz + 2^{k+1}z b_k) \]" src="form_92.png">
<p>
<p>
A necessary condition for <img class="formulaInl" alt="$ b_k = 1 $" src="form_93.png"> is that this equation is satisfied for <img class="formulaInl" alt="$ z = 0 $" src="form_94.png"> (as the second term is always non-negative). In fact, this condition is also sufficient, since we are looking for the <em>largest</em> solution <em>y</em>.<p>
This yields the following iterative algorithm. First, note that if <em>x</em> is stored in <em>n</em> bits, where <em>n</em> is even, then the integer square root does not require more than <img class="formulaInl" alt="$ m = n / 2 $" src="form_95.png"> bit to be stored. Thus initially, <img class="formulaInl" alt="$ w = 0 $" src="form_96.png"> and <img class="formulaInl" alt="$ k = m - 1 = n/2 - 1 $" src="form_97.png">. Then, at each iteration the equation is tested, determining <img class="formulaInl" alt="$ b_{m-1}, b_{m-2}, ... $" src="form_98.png"> in this order.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Approximation of <code>sqrt(x)</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="48bb7ee0a0b8f26c1ddcc8e9821f36ac"></a><!-- doxytag: member="mathop.h::vl_floor_d" ref="48bb7ee0a0b8f26c1ddcc8e9821f36ac" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE int vl_floor_d           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code></code>(int) floor(x) </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00138">138</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>Referenced by <a class="el" href="sift_8c-source.html#l00708">fast_expn()</a>, <a class="el" href="sift_8c-source.html#l01517">vl_sift_calc_keypoint_orientations()</a>, and <a class="el" href="sift_8c-source.html#l02068">vl_sift_keypoint_init()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0a641bb83f3aa7db107a51f63a534b52"></a><!-- doxytag: member="mathop.h::vl_floor_f" ref="0a641bb83f3aa7db107a51f63a534b52" args="(float x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE int vl_floor_f           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>argument. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code></code>(int) floor(x) </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00129">129</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>Referenced by <a class="el" href="dsift_8c-source.html#l00620">vl_dsift_process()</a>, <a class="el" href="sift_8c-source.html#l01881">vl_sift_calc_keypoint_descriptor()</a>, and <a class="el" href="sift_8c-source.html#l01712">vl_sift_calc_raw_descriptor()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b3a92ebb19b74de0f5853016c70fe7b0"></a><!-- doxytag: member="mathop.h::vl_mod_2pi_d" ref="b3a92ebb19b74de0f5853016c70fe7b0" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE double vl_mod_2pi_d           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>input value.</td></tr>
  </table>
</dl>
The function is optimized for small absolute values of <em>x</em>.<p>
The result is guaranteed not to be smaller than 0. However, due to finite numerical precision and rounding errors, the result can be equal to 2 * VL_PI (for instance, if <code>x</code> is a very small negative number).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>mod(x, 2 * VL_PI)</code> </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00112">112</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>References <a class="el" href="mathop_8h-source.html#l00022">VL_PI</a>.</p>

</div>
</div><p>
<a class="anchor" name="779371154b6f6c1a0f9bf51ad9afcd07"></a><!-- doxytag: member="mathop.h::vl_mod_2pi_f" ref="779371154b6f6c1a0f9bf51ad9afcd07" args="(float x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE float vl_mod_2pi_f           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>input value.</td></tr>
  </table>
</dl>
The function is optimized for small absolute values of <em>x</em>.<p>
The result is guaranteed not to be smaller than 0. However, due to finite numerical precision and rounding errors, the result can be equal to 2 * VL_PI (for instance, if <code>x</code> is a very small negative number).<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>mod(x, 2 * VL_PI)</code> </dd></dl>

<p>Definition at line <a class="el" href="mathop_8h-source.html#l00104">104</a> of file <a class="el" href="mathop_8h-source.html">mathop.h</a>.</p>

<p>References <a class="el" href="mathop_8h-source.html#l00022">VL_PI</a>.</p>

<p>Referenced by <a class="el" href="dsift_8c-source.html#l00620">vl_dsift_process()</a>, <a class="el" href="sift_8c-source.html#l01881">vl_sift_calc_keypoint_descriptor()</a>, and <a class="el" href="sift_8c-source.html#l01712">vl_sift_calc_raw_descriptor()</a>.</p>

</div>
</div><p>
</div>
    <!-- Doc Here -->
   </div>
  
   </div>
   <div class="clear">&nbsp;</div>
  </div> <!-- pagebody -->
  <div id="footer">
   &copy; 2005-09 Andrea Vedaldi and Brian Fulkerson
  </div> <!-- footer -->
  
  <!-- Google Analytics Begins -->
  <script xml:space="preserve" type="text/javascript">
   //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {
   var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
   document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
   }
   //]]>
  </script>
  <script xml:space="preserve" type="text/javascript">
    //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {

   try {
   var pageTracker = _gat._getTracker("UA-4936091-2");
   pageTracker._trackPageview();
   } catch(err) {}

   }
   //]]>
  </script>
  <!-- Google Analytics Ends -->
 </body>
</html>

 
