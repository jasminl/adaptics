<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">   
 <meta>
  <!-- Stylesheets -->
  <link href="../web.css" type="text/css" rel="stylesheet"></link>
  <title>VLFeat - C API</title>
  
  
  <!-- Scripts-->
 
 </meta>
 
 <!-- Body Start -->
 <body>
  <div id="header">
   <!-- Google CSE Search Box Begins -->
   <form action=" http://www.vlfeat.org/search.html" method="get" id="cse-search-box" enctype="application/x-www-form-urlencoded">
    <div>
     <input type="hidden" name="cx" value="003215582122030917471:oq23albfeam"></input>
     <input type="hidden" name="cof" value="FORID:11"></input>
     <input type="hidden" name="ie" value="UTF-8"></input>
     <input type="text" name="q" size="31"></input>
     <input type="submit" name="sa" value="Search"></input>
    </div>
   </form>
   <script src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" xml:space="preserve" type="text/javascript"></script>
   <!-- Google CSE Search Box Ends -->
   <h1>VLFeat.org</h1>
  </div>
  <div id="headbanner">
  C API
  </div>
  <div id="pagebody">
   <div id="sidebar"> <!-- Navigation Start -->
   <ul>
<li><a href="../index.html">Home</a>
</li>
<li><a href="../download.html">Download</a>
</li>
<li><a href="index.html" class='active' >C API</a>
</li>
<li><a href="../mdoc/mdoc.html">Matlab API</a>
</li>
<li><a href="../man/man.html">Man pages</a>
</li>
<li><a href="../overview/tut.html">Tutorials</a>
</li>
</ul>

   </div> <!-- sidebar -->
   <div id="content">
   
   <div class="doxygen">
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>sift.c</h1><a href="sift_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00007"></a>00007 <span class="comment">/* AUTORIGHTS</span>
<a name="l00008"></a>00008 <span class="comment">Copyright 2007 (c) Andrea Vedaldi and Brian Fulkerson</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">This file is part of VLFeat, available in the terms of the GNU</span>
<a name="l00011"></a>00011 <span class="comment">General Public License version 2.</span>
<a name="l00012"></a>00012 <span class="comment">*/</span>
<a name="l00013"></a>00013 
<a name="l00674"></a>00674 <span class="preprocessor">#include "<a class="code" href="sift_8h.html" title="Scale Invariant Feature Transform (SIFT).">sift.h</a>"</span>
<a name="l00675"></a>00675 <span class="preprocessor">#include "<a class="code" href="imop_8h.html" title="Image operations.">imop.h</a>"</span>
<a name="l00676"></a>00676 <span class="preprocessor">#include "<a class="code" href="mathop_8h.html" title="Math operations.">mathop.h</a>"</span>
<a name="l00677"></a>00677 
<a name="l00678"></a>00678 <span class="preprocessor">#include &lt;assert.h&gt;</span>
<a name="l00679"></a>00679 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00680"></a>00680 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00681"></a>00681 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00682"></a>00682 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00683"></a>00683 
<a name="l00685"></a>00685 <span class="preprocessor">#define VL_SIFT_BILINEAR_ORIENTATIONS 1</span>
<a name="l00686"></a>00686 <span class="preprocessor"></span>
<a name="l00687"></a>00687 <span class="preprocessor">#define EXPN_SZ  256          </span>
<a name="l00688"></a>00688 <span class="preprocessor">#define EXPN_MAX 25.0         </span>
<a name="l00689"></a><a class="code" href="sift_8c.html#6bfe7ecf9f4b9125e9613e90e4dc8971">00689</a> <span class="preprocessor">double expn_tab [EXPN_SZ+1] ; </span>
<a name="l00691"></a>00691 <span class="preprocessor">#define NBO 8</span>
<a name="l00692"></a>00692 <span class="preprocessor"></span><span class="preprocessor">#define NBP 4</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>
<a name="l00694"></a>00694 <span class="preprocessor">#define log2(x) (log(x)/VL_LOG_OF_2)</span>
<a name="l00695"></a>00695 <span class="preprocessor"></span>
<a name="l00707"></a>00707 VL_INLINE <span class="keywordtype">double</span>
<a name="l00708"></a><a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f">00708</a> <a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f" title="Fast  approximation.">fast_expn</a> (<span class="keywordtype">double</span> x)
<a name="l00709"></a>00709 {
<a name="l00710"></a>00710   <span class="keywordtype">double</span> a,b,r ;
<a name="l00711"></a>00711   <span class="keywordtype">int</span> i ;
<a name="l00712"></a>00712   <span class="comment">/*assert(0 &lt;= x &amp;&amp; x &lt;= EXPN_MAX) ;*/</span>
<a name="l00713"></a>00713 
<a name="l00714"></a>00714   <span class="keywordflow">if</span> (x &gt; EXPN_MAX) <span class="keywordflow">return</span> 0.0 ;
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   x *= EXPN_SZ / EXPN_MAX ;
<a name="l00717"></a>00717   i = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (x) ;
<a name="l00718"></a>00718   r = x - i ;
<a name="l00719"></a>00719   a = <a class="code" href="sift_8c.html#6bfe7ecf9f4b9125e9613e90e4dc8971">expn_tab</a> [i    ] ;
<a name="l00720"></a>00720   b = <a class="code" href="sift_8c.html#6bfe7ecf9f4b9125e9613e90e4dc8971">expn_tab</a> [i + 1] ;
<a name="l00721"></a>00721   <span class="keywordflow">return</span> a + r * (b - a) ;
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00729"></a>00729 VL_INLINE <span class="keywordtype">void</span>
<a name="l00730"></a><a class="code" href="sift_8c.html#c0f5ab6b07f3edd4728f6c7439f886f4">00730</a> <a class="code" href="sift_8c.html#c0f5ab6b07f3edd4728f6c7439f886f4" title="Initialize tables for fast_expn.">fast_expn_init</a> ()
<a name="l00731"></a>00731 {
<a name="l00732"></a>00732   <span class="keywordtype">int</span> k  ;
<a name="l00733"></a>00733   <span class="keywordflow">for</span>(k = 0 ; k &lt; EXPN_SZ + 1 ; ++ k) {
<a name="l00734"></a>00734     <a class="code" href="sift_8c.html#6bfe7ecf9f4b9125e9613e90e4dc8971">expn_tab</a> [k] = exp (- (<span class="keywordtype">double</span>) k * (EXPN_MAX / EXPN_SZ)) ;
<a name="l00735"></a>00735   }
<a name="l00736"></a>00736 }
<a name="l00737"></a>00737 
<a name="l00754"></a>00754 <span class="keyword">static</span> <span class="keywordtype">void</span> 
<a name="l00755"></a>00755 <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a> 
<a name="l00756"></a><a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29">00756</a> (<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>       *dst, 
<a name="l00757"></a>00757  <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *src, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
<a name="l00758"></a>00758 {
<a name="l00759"></a>00759   <span class="keywordtype">int</span> x, y ;
<a name="l00760"></a>00760   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> a, b ;
<a name="l00761"></a>00761 
<a name="l00762"></a>00762   <span class="keywordflow">for</span>(y = 0 ; y &lt; height ; ++y) {
<a name="l00763"></a>00763     b = a = *src++ ;
<a name="l00764"></a>00764     <span class="keywordflow">for</span>(x = 0 ; x &lt; width - 1 ; ++x) {
<a name="l00765"></a>00765       b = *src++ ;
<a name="l00766"></a>00766       *dst = a ;             dst += height ;
<a name="l00767"></a>00767       *dst = 0.5 * (a + b) ; dst += height ;
<a name="l00768"></a>00768       a = b ;
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770     *dst = b ; dst += height ;
<a name="l00771"></a>00771     *dst = b ; dst += height ;
<a name="l00772"></a>00772     dst += 1 - width * 2 * height ;
<a name="l00773"></a>00773   }  
<a name="l00774"></a>00774 }
<a name="l00775"></a>00775 
<a name="l00793"></a>00793 <span class="keyword">static</span> <span class="keywordtype">void</span> 
<a name="l00794"></a>00794 <a class="code" href="sift_8c.html#457daa5f995f4b946c1a44a45e7702bb" title="Copy and downsample an image.">copy_and_downsample</a>
<a name="l00795"></a><a class="code" href="sift_8c.html#457daa5f995f4b946c1a44a45e7702bb">00795</a> (<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>       *dst, 
<a name="l00796"></a>00796  <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *src, 
<a name="l00797"></a>00797  <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> d)
<a name="l00798"></a>00798 {
<a name="l00799"></a>00799   <span class="keywordtype">int</span> x, y ;
<a name="l00800"></a>00800 
<a name="l00801"></a>00801   d = 1 &lt;&lt; d ; <span class="comment">/* d = 2^d */</span>
<a name="l00802"></a>00802   <span class="keywordflow">for</span>(y = 0 ; y &lt; height ; y+=d) {
<a name="l00803"></a>00803     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> * srcrowp = src + y * width ;    
<a name="l00804"></a>00804     <span class="keywordflow">for</span>(x = 0 ; x &lt; width - (d-1) ; x+=d) {     
<a name="l00805"></a>00805       *dst++ = *srcrowp ;
<a name="l00806"></a>00806       srcrowp += d ;
<a name="l00807"></a>00807     }
<a name="l00808"></a>00808   }
<a name="l00809"></a>00809 }
<a name="l00810"></a>00810 
<a name="l00830"></a>00830 VL_EXPORT
<a name="l00831"></a>00831 <a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *
<a name="l00832"></a><a class="code" href="sift_8h.html#7430415e1978727a55a29f203eb38d3e">00832</a> <a class="code" href="sift_8c.html#7430415e1978727a55a29f203eb38d3e" title="Create a new SIFT filter.">vl_sift_new</a> (<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height,
<a name="l00833"></a>00833              <span class="keywordtype">int</span> noctaves, <span class="keywordtype">int</span> nlevels,
<a name="l00834"></a>00834              <span class="keywordtype">int</span> o_min)
<a name="l00835"></a>00835 {
<a name="l00836"></a>00836   <a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a>)) ;
<a name="l00837"></a>00837 
<a name="l00838"></a>00838   <span class="keywordtype">int</span> w   = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a> (width,  -o_min) ;
<a name="l00839"></a>00839   <span class="keywordtype">int</span> h   = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a> (height, -o_min) ;
<a name="l00840"></a>00840   <span class="keywordtype">int</span> nel = w * h ;
<a name="l00841"></a>00841 
<a name="l00842"></a>00842   <span class="comment">/* negative value O =&gt; calculate max. value */</span>
<a name="l00843"></a>00843   <span class="keywordflow">if</span> (noctaves &lt; 0) {
<a name="l00844"></a>00844     noctaves = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (floor (log2 (<a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(width, height))) - o_min - 3, 1) ;
<a name="l00845"></a>00845   }
<a name="l00846"></a>00846 
<a name="l00847"></a>00847   f-&gt; width   = width ;
<a name="l00848"></a>00848   f-&gt; height  = height ;
<a name="l00849"></a>00849   f-&gt; O       = noctaves ;
<a name="l00850"></a>00850   f-&gt; S       = nlevels ;
<a name="l00851"></a>00851   f-&gt; o_min   = o_min ;
<a name="l00852"></a>00852   f-&gt; s_min   = -1 ;
<a name="l00853"></a>00853   f-&gt; s_max   = nlevels + 1 ;
<a name="l00854"></a>00854   f-&gt; o_cur   = o_min ;
<a name="l00855"></a>00855 
<a name="l00856"></a>00856   f-&gt; temp    = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * nel    ) ;
<a name="l00857"></a>00857   f-&gt; octave  = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * nel 
<a name="l00858"></a>00858                         * (f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> + 1)  ) ;
<a name="l00859"></a>00859   f-&gt; dog     = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * nel 
<a name="l00860"></a>00860                         * (f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a>    )  ) ;
<a name="l00861"></a>00861   f-&gt; grad    = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (<span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * nel * 2 
<a name="l00862"></a>00862                         * (f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a>    )  ) ;
<a name="l00863"></a>00863 
<a name="l00864"></a>00864   f-&gt; sigman  = 0.5 ;
<a name="l00865"></a>00865   f-&gt; sigma0  = 1.6 * pow (2.0, 1.0 / nlevels) ;      
<a name="l00866"></a>00866   f-&gt; sigmak  =       pow (2.0, 1.0 / nlevels) ;
<a name="l00867"></a>00867   f-&gt; dsigma0 = f-&gt;<a class="code" href="struct__VlSiftFilt.html#26c296dd10f53b29b32e40d73294bfc9">sigma0</a> * sqrt (1.0 - 1.0 / (f-&gt;<a class="code" href="struct__VlSiftFilt.html#1f91e8c9dbda42d613bf5d771328de7a">sigmak</a>*f-&gt;<a class="code" href="struct__VlSiftFilt.html#1f91e8c9dbda42d613bf5d771328de7a">sigmak</a>)) ;
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   <span class="comment">/*</span>
<a name="l00870"></a>00870 <span class="comment">  VL_PRINTF ("sigman = %g\n", f-&gt; sigman) ;</span>
<a name="l00871"></a>00871 <span class="comment">  VL_PRINTF ("sigma0 = %g\n", f-&gt; sigma0) ;</span>
<a name="l00872"></a>00872 <span class="comment">  */</span>
<a name="l00873"></a>00873 
<a name="l00874"></a>00874   f-&gt; octave_width  = 0 ;
<a name="l00875"></a>00875   f-&gt; octave_height = 0 ;
<a name="l00876"></a>00876 
<a name="l00877"></a>00877   f-&gt; keys     = 0 ;
<a name="l00878"></a>00878   f-&gt; nkeys    = 0 ;
<a name="l00879"></a>00879   f-&gt; keys_res = 0 ;
<a name="l00880"></a>00880 
<a name="l00881"></a>00881   f-&gt; peak_thresh = 0.0 ;
<a name="l00882"></a>00882   f-&gt; edge_thresh = 10.0 ;
<a name="l00883"></a>00883   f-&gt; norm_thresh = 0.0 ;
<a name="l00884"></a>00884   f-&gt; magnif      = 3.0 ;
<a name="l00885"></a>00885   f-&gt; windowSize  = NBP / 2 ;
<a name="l00886"></a>00886 
<a name="l00887"></a>00887   f-&gt; grad_o  = o_min - 1 ;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889   <span class="comment">/* initialize fast_expn stuff */</span>
<a name="l00890"></a>00890   <a class="code" href="sift_8c.html#c0f5ab6b07f3edd4728f6c7439f886f4" title="Initialize tables for fast_expn.">fast_expn_init</a> () ;
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <span class="keywordflow">return</span> f ;
<a name="l00893"></a>00893 }
<a name="l00894"></a>00894 
<a name="l00903"></a>00903 VL_EXPORT
<a name="l00904"></a>00904 <span class="keywordtype">void</span>
<a name="l00905"></a><a class="code" href="sift_8h.html#bcf6b47f064329813fa54d80310728cd">00905</a> <a class="code" href="sift_8c.html#bcf6b47f064329813fa54d80310728cd" title="Delete SIFT filter.">vl_sift_delete</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a>* f)
<a name="l00906"></a>00906 {
<a name="l00907"></a>00907   <span class="keywordflow">if</span>(f) {
<a name="l00908"></a>00908     <span class="keywordflow">if</span>(f-&gt; keys   ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; keys   ) ;
<a name="l00909"></a>00909     <span class="keywordflow">if</span>(f-&gt; grad   ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; grad   ) ;
<a name="l00910"></a>00910     <span class="keywordflow">if</span>(f-&gt; dog    ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; dog    ) ;
<a name="l00911"></a>00911     <span class="keywordflow">if</span>(f-&gt; octave ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; octave ) ;
<a name="l00912"></a>00912     <span class="keywordflow">if</span>(f-&gt; temp   ) <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f-&gt; temp   ) ;
<a name="l00913"></a>00913     <a class="code" href="generic_8h.html#bb97ff524f46d6c5ce9ca8af9e792cc3" title="Call customizable free function.">vl_free</a> (f) ;
<a name="l00914"></a>00914   }
<a name="l00915"></a>00915 }
<a name="l00916"></a>00916 
<a name="l00933"></a>00933 VL_EXPORT
<a name="l00934"></a>00934 <span class="keywordtype">int</span>
<a name="l00935"></a><a class="code" href="sift_8h.html#774f028cadf0fc556bfd6170eb0033b9">00935</a> <a class="code" href="sift_8c.html#774f028cadf0fc556bfd6170eb0033b9" title="Start processing a new image.">vl_sift_process_first_octave</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f, <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *im)
<a name="l00936"></a>00936 {
<a name="l00937"></a>00937   <span class="keywordtype">int</span> o, s, h, w ;
<a name="l00938"></a>00938   <span class="keywordtype">double</span> sa, sb ;
<a name="l00939"></a>00939   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *octave ;
<a name="l00940"></a>00940   
<a name="l00941"></a>00941   <span class="comment">/* shortcuts */</span>
<a name="l00942"></a>00942   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *temp   = f-&gt; temp ;
<a name="l00943"></a>00943   <span class="keywordtype">int</span> width           = f-&gt; width ;
<a name="l00944"></a>00944   <span class="keywordtype">int</span> height          = f-&gt; height ;
<a name="l00945"></a>00945   <span class="keywordtype">int</span> o_min           = f-&gt; o_min ;
<a name="l00946"></a>00946   <span class="keywordtype">int</span> s_min           = f-&gt; s_min ;
<a name="l00947"></a>00947   <span class="keywordtype">int</span> s_max           = f-&gt; s_max ;
<a name="l00948"></a>00948   <span class="keywordtype">double</span> sigma0       = f-&gt; sigma0 ;
<a name="l00949"></a>00949   <span class="keywordtype">double</span> sigmak       = f-&gt; sigmak ;
<a name="l00950"></a>00950   <span class="keywordtype">double</span> sigman       = f-&gt; sigman ;
<a name="l00951"></a>00951   <span class="keywordtype">double</span> dsigma0      = f-&gt; dsigma0 ; 
<a name="l00952"></a>00952 
<a name="l00953"></a>00953   <span class="comment">/* restart from the first */</span>
<a name="l00954"></a>00954   f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a> = o_min ;
<a name="l00955"></a>00955   f-&gt;<a class="code" href="struct__VlSiftFilt.html#7e4bab1036ea1bda1dbc2f9afc802706">nkeys</a> = 0 ;
<a name="l00956"></a>00956   w = f-&gt; octave_width  = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a>(f-&gt;<a class="code" href="struct__VlSiftFilt.html#1906b63621988a3851416bfc87156536">width</a>,  - f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l00957"></a>00957   h = f-&gt; octave_height = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a>(f-&gt;<a class="code" href="struct__VlSiftFilt.html#f5c34894fe67875df1c9421584dce8b9">height</a>, - f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959   <span class="comment">/* is there at least one octave? */</span>
<a name="l00960"></a>00960   <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#e36d5a3c012a53484bbf7ef1a125e69e">O</a> == 0)
<a name="l00961"></a>00961     <span class="keywordflow">return</span> <a class="code" href="generic_8h.html#67cc69e40d7af2aec137b36e53422982">VL_ERR_EOF</a> ;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <span class="comment">/* ------------------------------------------------------------------</span>
<a name="l00964"></a>00964 <span class="comment">   *                     Compute the first sublevel of the first octave</span>
<a name="l00965"></a>00965 <span class="comment">   * --------------------------------------------------------------- */</span>
<a name="l00966"></a>00966   
<a name="l00967"></a>00967   <span class="comment">/* </span>
<a name="l00968"></a>00968 <span class="comment">   * If the first octave has negative index, we upscale the image; if</span>
<a name="l00969"></a>00969 <span class="comment">   * the first octave has positive index, we downscale the image; if</span>
<a name="l00970"></a>00970 <span class="comment">   * the first octave has index zero, we just copy the image.</span>
<a name="l00971"></a>00971 <span class="comment">   */</span>
<a name="l00972"></a>00972   
<a name="l00973"></a>00973   octave = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a> (f, s_min) ;
<a name="l00974"></a>00974   
<a name="l00975"></a>00975   <span class="keywordflow">if</span> (o_min &lt; 0) {
<a name="l00976"></a>00976     <span class="comment">/* double once */</span>
<a name="l00977"></a>00977     <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a> (temp,   im,   width,      height) ;
<a name="l00978"></a>00978     <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a> (octave, temp, height, 2 * width ) ;
<a name="l00979"></a>00979 
<a name="l00980"></a>00980     <span class="comment">/* double more */</span>
<a name="l00981"></a>00981     <span class="keywordflow">for</span>(o = -1 ; o &gt; o_min ; --o) {
<a name="l00982"></a>00982       <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a> (temp, octave, 
<a name="l00983"></a>00983                               width &lt;&lt; -o,      height &lt;&lt; -o ) ; 
<a name="l00984"></a>00984       <a class="code" href="sift_8c.html#eb42c89bf4510234d60ba3eef7010c29" title="Copy image, upsample rows and take transpose.">copy_and_upsample_rows</a> (octave, temp,   
<a name="l00985"></a>00985                               width &lt;&lt; -o, 2 * (height &lt;&lt; -o)) ; 
<a name="l00986"></a>00986     }        
<a name="l00987"></a>00987   } 
<a name="l00988"></a>00988   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (o_min &gt; 0) {
<a name="l00989"></a>00989     <span class="comment">/* downsample */</span>
<a name="l00990"></a>00990     <a class="code" href="sift_8c.html#457daa5f995f4b946c1a44a45e7702bb" title="Copy and downsample an image.">copy_and_downsample</a> (octave, im, width, height, o_min) ;
<a name="l00991"></a>00991   } 
<a name="l00992"></a>00992   <span class="keywordflow">else</span> {
<a name="l00993"></a>00993     <span class="comment">/* direct copy */</span>
<a name="l00994"></a>00994     memcpy(octave, im, <span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * width * height) ;
<a name="l00995"></a>00995   }
<a name="l00996"></a>00996   
<a name="l00997"></a>00997   <span class="comment">/* </span>
<a name="l00998"></a>00998 <span class="comment">   * Here we adjust the smoothing of the first level of the octave.</span>
<a name="l00999"></a>00999 <span class="comment">   * The input image is assumed to have nominal smoothing equal to</span>
<a name="l01000"></a>01000 <span class="comment">   * f-&gt;simgan.</span>
<a name="l01001"></a>01001 <span class="comment">   */</span>
<a name="l01002"></a>01002   
<a name="l01003"></a>01003   sa = sigma0 * pow (sigmak,   s_min) ;
<a name="l01004"></a>01004   sb = sigman * pow (2.0,    - o_min) ;
<a name="l01005"></a>01005 
<a name="l01006"></a>01006   <span class="keywordflow">if</span> (sa &gt; sb) {
<a name="l01007"></a>01007     <span class="keywordtype">double</span> sd = sqrt (sa*sa - sb*sb) ;
<a name="l01008"></a>01008     <a class="code" href="imop_8h.html#1a4f88af24e32dea5e6a84cf3c7590d8" title="Smooth image by Gaussian kernel.">vl_imsmooth_f</a> (octave, temp, octave, w, h, sd) ;
<a name="l01009"></a>01009   }
<a name="l01010"></a>01010   
<a name="l01011"></a>01011   <span class="comment">/* -----------------------------------------------------------------</span>
<a name="l01012"></a>01012 <span class="comment">   *                                          Compute the first octave</span>
<a name="l01013"></a>01013 <span class="comment">   * -------------------------------------------------------------- */</span>
<a name="l01014"></a>01014   
<a name="l01015"></a>01015   <span class="keywordflow">for</span>(s = s_min + 1 ; s &lt;= s_max ; ++s) {
<a name="l01016"></a>01016     <span class="keywordtype">double</span> sd = dsigma0 * pow (sigmak, s) ;
<a name="l01017"></a>01017     <a class="code" href="imop_8h.html#1a4f88af24e32dea5e6a84cf3c7590d8" title="Smooth image by Gaussian kernel.">vl_imsmooth_f</a> (<a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>(f, s    ), temp, 
<a name="l01018"></a>01018                    <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>(f, s - 1), w, h, sd) ;
<a name="l01019"></a>01019   }
<a name="l01020"></a>01020   
<a name="l01021"></a>01021   <span class="keywordflow">return</span> <a class="code" href="generic_8h.html#26519a3dd2966d2d46538eb46921abba">VL_ERR_OK</a> ;
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 
<a name="l01039"></a>01039 VL_EXPORT
<a name="l01040"></a>01040 <span class="keywordtype">int</span>
<a name="l01041"></a><a class="code" href="sift_8h.html#a46dad3788e44ffb6aed2ccb8c445c2d">01041</a> <a class="code" href="sift_8c.html#a46dad3788e44ffb6aed2ccb8c445c2d" title="Process next octave.">vl_sift_process_next_octave</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f)
<a name="l01042"></a>01042 {
<a name="l01043"></a>01043 
<a name="l01044"></a>01044   <span class="keywordtype">int</span> s, h, w, s_best ;
<a name="l01045"></a>01045   <span class="keywordtype">double</span> sa, sb ;
<a name="l01046"></a>01046   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *octave, *pt ;
<a name="l01047"></a>01047   
<a name="l01048"></a>01048   <span class="comment">/* shortcuts */</span>
<a name="l01049"></a>01049   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *temp   = f-&gt; temp ;
<a name="l01050"></a>01050   <span class="keywordtype">int</span> O               = f-&gt; O ;
<a name="l01051"></a>01051   <span class="keywordtype">int</span> S               = f-&gt; S ;
<a name="l01052"></a>01052   <span class="keywordtype">int</span> o_min           = f-&gt; o_min ;
<a name="l01053"></a>01053   <span class="keywordtype">int</span> s_min           = f-&gt; s_min ;
<a name="l01054"></a>01054   <span class="keywordtype">int</span> s_max           = f-&gt; s_max ;
<a name="l01055"></a>01055   <span class="keywordtype">double</span> sigma0       = f-&gt; sigma0 ;
<a name="l01056"></a>01056   <span class="keywordtype">double</span> sigmak       = f-&gt; sigmak ;
<a name="l01057"></a>01057   <span class="keywordtype">double</span> dsigma0      = f-&gt; dsigma0 ; 
<a name="l01058"></a>01058 
<a name="l01059"></a>01059   <span class="comment">/* is there another octave ? */</span>
<a name="l01060"></a>01060   <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a> == o_min + O - 1)
<a name="l01061"></a>01061     <span class="keywordflow">return</span> <a class="code" href="generic_8h.html#67cc69e40d7af2aec137b36e53422982">VL_ERR_EOF</a> ;
<a name="l01062"></a>01062 
<a name="l01063"></a>01063   <span class="comment">/* retrieve base */</span>
<a name="l01064"></a>01064   s_best = <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(s_min + S, s_max) ;
<a name="l01065"></a>01065   w      = <a class="code" href="sift_8h.html#5d04844056daf18bdd9ad581e4f716eb" title="Get current octave width.">vl_sift_get_octave_width</a>  (f) ;
<a name="l01066"></a>01066   h      = <a class="code" href="sift_8h.html#d5b6d41bea03ce9fef51ba477260cd7e" title="Get current octave height.">vl_sift_get_octave_height</a> (f) ;
<a name="l01067"></a>01067   pt     = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>        (f, s_best) ;
<a name="l01068"></a>01068   octave = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>        (f, s_min) ;
<a name="l01069"></a>01069 
<a name="l01070"></a>01070   <span class="comment">/* next octave */</span>
<a name="l01071"></a>01071   <a class="code" href="sift_8c.html#457daa5f995f4b946c1a44a45e7702bb" title="Copy and downsample an image.">copy_and_downsample</a> (octave, pt, w, h, 1) ;
<a name="l01072"></a>01072 
<a name="l01073"></a>01073   f-&gt; o_cur            += 1 ;
<a name="l01074"></a>01074   f-&gt; nkeys             = 0 ;
<a name="l01075"></a>01075   w = f-&gt; octave_width  = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a>(f-&gt;<a class="code" href="struct__VlSiftFilt.html#1906b63621988a3851416bfc87156536">width</a>,  - f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01076"></a>01076   h = f-&gt; octave_height = <a class="code" href="generic_8h.html#ee17b425e4672e582e26cf9e103fc0fb" title="Signed left shift operation.">VL_SHIFT_LEFT</a>(f-&gt;<a class="code" href="struct__VlSiftFilt.html#f5c34894fe67875df1c9421584dce8b9">height</a>, - f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01077"></a>01077   
<a name="l01078"></a>01078   sa = sigma0 * powf (sigmak, s_min     ) ;
<a name="l01079"></a>01079   sb = sigma0 * powf (sigmak, s_best - S) ;
<a name="l01080"></a>01080 
<a name="l01081"></a>01081   <span class="keywordflow">if</span> (sa &gt; sb) {
<a name="l01082"></a>01082     <span class="keywordtype">double</span> sd = sqrt (sa*sa - sb*sb) ;
<a name="l01083"></a>01083     <a class="code" href="imop_8h.html#1a4f88af24e32dea5e6a84cf3c7590d8" title="Smooth image by Gaussian kernel.">vl_imsmooth_f</a> (octave, temp, octave, w, h, sd) ;
<a name="l01084"></a>01084   }
<a name="l01085"></a>01085 
<a name="l01086"></a>01086   <span class="comment">/* ------------------------------------------------------------------</span>
<a name="l01087"></a>01087 <span class="comment">   *                                                        Fill octave</span>
<a name="l01088"></a>01088 <span class="comment">   * --------------------------------------------------------------- */</span>
<a name="l01089"></a>01089   
<a name="l01090"></a>01090   <span class="keywordflow">for</span>(s = s_min + 1 ; s &lt;= s_max ; ++s) {
<a name="l01091"></a>01091     <span class="keywordtype">double</span> sd = dsigma0 * pow (sigmak, s) ;
<a name="l01092"></a>01092     <a class="code" href="imop_8h.html#1a4f88af24e32dea5e6a84cf3c7590d8" title="Smooth image by Gaussian kernel.">vl_imsmooth_f</a> (<a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>(f, s    ), temp, 
<a name="l01093"></a>01093                    <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a>(f, s - 1), w, h, sd) ;
<a name="l01094"></a>01094   }
<a name="l01095"></a>01095 
<a name="l01096"></a>01096   <span class="keywordflow">return</span> <a class="code" href="generic_8h.html#26519a3dd2966d2d46538eb46921abba">VL_ERR_OK</a> ;
<a name="l01097"></a>01097 }
<a name="l01098"></a>01098 
<a name="l01109"></a>01109 VL_EXPORT
<a name="l01110"></a>01110 <span class="keywordtype">void</span>
<a name="l01111"></a><a class="code" href="sift_8h.html#248f0925ed45fa4632ea30fa9b2229af">01111</a> <a class="code" href="sift_8c.html#248f0925ed45fa4632ea30fa9b2229af" title="Detect keypoints.">vl_sift_detect</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> * f)
<a name="l01112"></a>01112 {  
<a name="l01113"></a>01113   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* dog   = f-&gt; dog ;
<a name="l01114"></a>01114   <span class="keywordtype">int</span>          s_min = f-&gt; s_min ;
<a name="l01115"></a>01115   <span class="keywordtype">int</span>          s_max = f-&gt; s_max ;
<a name="l01116"></a>01116   <span class="keywordtype">int</span>          w     = f-&gt; octave_width ;
<a name="l01117"></a>01117   <span class="keywordtype">int</span>          h     = f-&gt; octave_height ;
<a name="l01118"></a>01118   <span class="keywordtype">double</span>       te    = f-&gt; edge_thresh ;
<a name="l01119"></a>01119   <span class="keywordtype">double</span>       tp    = f-&gt; peak_thresh ;
<a name="l01120"></a>01120   
<a name="l01121"></a>01121   <span class="keywordtype">int</span> <span class="keyword">const</span>    xo    = 1 ;      <span class="comment">/* x-stride */</span>
<a name="l01122"></a>01122   <span class="keywordtype">int</span> <span class="keyword">const</span>    yo    = w ;      <span class="comment">/* y-stride */</span>
<a name="l01123"></a>01123   <span class="keywordtype">int</span> <span class="keyword">const</span>    so    = w * h ;  <span class="comment">/* s-stride */</span>
<a name="l01124"></a>01124 
<a name="l01125"></a>01125   <span class="keywordtype">double</span>       xper  = pow (2.0, f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01126"></a>01126 
<a name="l01127"></a>01127   <span class="keywordtype">int</span> x, y, s, i, ii, jj ;
<a name="l01128"></a>01128   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *pt, v ;
<a name="l01129"></a>01129   <a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a> *k ;
<a name="l01130"></a>01130 
<a name="l01131"></a>01131   <span class="comment">/* clear current list */</span>
<a name="l01132"></a>01132   f-&gt; nkeys = 0 ;
<a name="l01133"></a>01133     
<a name="l01134"></a>01134   <span class="comment">/* compute difference of gaussian (DoG) */</span>  
<a name="l01135"></a>01135   pt = f-&gt; dog ;
<a name="l01136"></a>01136   <span class="keywordflow">for</span> (s = s_min ; s &lt;= s_max - 1 ; ++s) {
<a name="l01137"></a>01137     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* src_a = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a> (f, s    ) ;
<a name="l01138"></a>01138     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* src_b = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a> (f, s + 1) ;
<a name="l01139"></a>01139     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* end_a = src_a + w * h ;
<a name="l01140"></a>01140     <span class="keywordflow">while</span> (src_a != end_a) {
<a name="l01141"></a>01141       *pt++ = *src_b++ - *src_a++ ;
<a name="l01142"></a>01142     }
<a name="l01143"></a>01143   }
<a name="l01144"></a>01144   
<a name="l01145"></a>01145   <span class="comment">/* -----------------------------------------------------------------</span>
<a name="l01146"></a>01146 <span class="comment">   *                                          Find local maxima of DoG</span>
<a name="l01147"></a>01147 <span class="comment">   * -------------------------------------------------------------- */</span>
<a name="l01148"></a>01148 
<a name="l01149"></a>01149   <span class="comment">/* start from dog [1,1,s_min+1] */</span>
<a name="l01150"></a>01150   pt  = dog + xo + yo + so ;
<a name="l01151"></a>01151   
<a name="l01152"></a>01152   <span class="keywordflow">for</span>(s = s_min + 1 ; s &lt;= s_max - 2 ; ++s) {
<a name="l01153"></a>01153     <span class="keywordflow">for</span>(y = 1 ; y &lt; h - 1 ; ++y) {
<a name="l01154"></a>01154       <span class="keywordflow">for</span>(x = 1 ; x &lt; w - 1 ; ++x) {          
<a name="l01155"></a>01155         v = *pt ;
<a name="l01156"></a>01156                
<a name="l01157"></a>01157 <span class="preprocessor">#define CHECK_NEIGHBORS(CMP,SGN)                    \</span>
<a name="l01158"></a>01158 <span class="preprocessor">        ( v CMP ## = SGN 0.8 * tp &amp;&amp;                \</span>
<a name="l01159"></a>01159 <span class="preprocessor">          v CMP *(pt + xo) &amp;&amp;                       \</span>
<a name="l01160"></a>01160 <span class="preprocessor">          v CMP *(pt - xo) &amp;&amp;                       \</span>
<a name="l01161"></a>01161 <span class="preprocessor">          v CMP *(pt + so) &amp;&amp;                       \</span>
<a name="l01162"></a>01162 <span class="preprocessor">          v CMP *(pt - so) &amp;&amp;                       \</span>
<a name="l01163"></a>01163 <span class="preprocessor">          v CMP *(pt + yo) &amp;&amp;                       \</span>
<a name="l01164"></a>01164 <span class="preprocessor">          v CMP *(pt - yo) &amp;&amp;                       \</span>
<a name="l01165"></a>01165 <span class="preprocessor">                                                    \</span>
<a name="l01166"></a>01166 <span class="preprocessor">          v CMP *(pt + yo + xo) &amp;&amp;                  \</span>
<a name="l01167"></a>01167 <span class="preprocessor">          v CMP *(pt + yo - xo) &amp;&amp;                  \</span>
<a name="l01168"></a>01168 <span class="preprocessor">          v CMP *(pt - yo + xo) &amp;&amp;                  \</span>
<a name="l01169"></a>01169 <span class="preprocessor">          v CMP *(pt - yo - xo) &amp;&amp;                  \</span>
<a name="l01170"></a>01170 <span class="preprocessor">                                                    \</span>
<a name="l01171"></a>01171 <span class="preprocessor">          v CMP *(pt + xo      + so) &amp;&amp;             \</span>
<a name="l01172"></a>01172 <span class="preprocessor">          v CMP *(pt - xo      + so) &amp;&amp;             \</span>
<a name="l01173"></a>01173 <span class="preprocessor">          v CMP *(pt + yo      + so) &amp;&amp;             \</span>
<a name="l01174"></a>01174 <span class="preprocessor">          v CMP *(pt - yo      + so) &amp;&amp;             \</span>
<a name="l01175"></a>01175 <span class="preprocessor">          v CMP *(pt + yo + xo + so) &amp;&amp;             \</span>
<a name="l01176"></a>01176 <span class="preprocessor">          v CMP *(pt + yo - xo + so) &amp;&amp;             \</span>
<a name="l01177"></a>01177 <span class="preprocessor">          v CMP *(pt - yo + xo + so) &amp;&amp;             \</span>
<a name="l01178"></a>01178 <span class="preprocessor">          v CMP *(pt - yo - xo + so) &amp;&amp;             \</span>
<a name="l01179"></a>01179 <span class="preprocessor">                                                    \</span>
<a name="l01180"></a>01180 <span class="preprocessor">          v CMP *(pt + xo      - so) &amp;&amp;             \</span>
<a name="l01181"></a>01181 <span class="preprocessor">          v CMP *(pt - xo      - so) &amp;&amp;             \</span>
<a name="l01182"></a>01182 <span class="preprocessor">          v CMP *(pt + yo      - so) &amp;&amp;             \</span>
<a name="l01183"></a>01183 <span class="preprocessor">          v CMP *(pt - yo      - so) &amp;&amp;             \</span>
<a name="l01184"></a>01184 <span class="preprocessor">          v CMP *(pt + yo + xo - so) &amp;&amp;             \</span>
<a name="l01185"></a>01185 <span class="preprocessor">          v CMP *(pt + yo - xo - so) &amp;&amp;             \</span>
<a name="l01186"></a>01186 <span class="preprocessor">          v CMP *(pt - yo + xo - so) &amp;&amp;             \</span>
<a name="l01187"></a>01187 <span class="preprocessor">          v CMP *(pt - yo - xo - so) )</span>
<a name="l01188"></a>01188 <span class="preprocessor"></span>        
<a name="l01189"></a>01189         <span class="keywordflow">if</span> (CHECK_NEIGHBORS(&gt;,+) || 
<a name="l01190"></a>01190             CHECK_NEIGHBORS(&lt;,-) ) {
<a name="l01191"></a>01191           
<a name="l01192"></a>01192           <span class="comment">/* make room for more keypoints */</span>
<a name="l01193"></a>01193           <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#7e4bab1036ea1bda1dbc2f9afc802706">nkeys</a> &gt;= f-&gt;<a class="code" href="struct__VlSiftFilt.html#30c797b88b552d10216a6d61d7eeb1de">keys_res</a>) {
<a name="l01194"></a>01194             f-&gt;<a class="code" href="struct__VlSiftFilt.html#30c797b88b552d10216a6d61d7eeb1de">keys_res</a> += 500 ;
<a name="l01195"></a>01195             <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a>) {
<a name="l01196"></a>01196               f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> = <a class="code" href="generic_8h.html#e39d0b3bbe1fc3402febdbab894f2207" title="Call customizable resize function.">vl_realloc</a> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a>,
<a name="l01197"></a>01197                                     f-&gt;<a class="code" href="struct__VlSiftFilt.html#30c797b88b552d10216a6d61d7eeb1de">keys_res</a> * 
<a name="l01198"></a>01198                                     <span class="keyword">sizeof</span>(<a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a>)) ;
<a name="l01199"></a>01199             } <span class="keywordflow">else</span> {
<a name="l01200"></a>01200               f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> = <a class="code" href="generic_8h.html#e28d261fc7cc26f1457b171d842b53ab" title="Call customizable malloc function.">vl_malloc</a> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#30c797b88b552d10216a6d61d7eeb1de">keys_res</a> * 
<a name="l01201"></a>01201                                    <span class="keyword">sizeof</span>(<a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a>)) ;
<a name="l01202"></a>01202             }
<a name="l01203"></a>01203           }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205           k = f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> + (f-&gt;<a class="code" href="struct__VlSiftFilt.html#7e4bab1036ea1bda1dbc2f9afc802706">nkeys</a> ++) ;
<a name="l01206"></a>01206           
<a name="l01207"></a>01207           k-&gt; ix = x ;
<a name="l01208"></a>01208           k-&gt; iy = y ;
<a name="l01209"></a>01209           k-&gt; is = s ;
<a name="l01210"></a>01210         }                 
<a name="l01211"></a>01211         pt += 1 ;
<a name="l01212"></a>01212       }
<a name="l01213"></a>01213       pt += 2 ;
<a name="l01214"></a>01214     }
<a name="l01215"></a>01215     pt += 2 * yo ;
<a name="l01216"></a>01216   }
<a name="l01217"></a>01217   
<a name="l01218"></a>01218   <span class="comment">/* -----------------------------------------------------------------</span>
<a name="l01219"></a>01219 <span class="comment">   *                                               Refine local maxima</span>
<a name="l01220"></a>01220 <span class="comment">   * -------------------------------------------------------------- */</span>
<a name="l01221"></a>01221 
<a name="l01222"></a>01222   <span class="comment">/* this pointer is used to write the keypoints back */</span>
<a name="l01223"></a>01223   k = f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> ;
<a name="l01224"></a>01224 
<a name="l01225"></a>01225   <span class="keywordflow">for</span> (i = 0 ; i &lt; f-&gt;<a class="code" href="struct__VlSiftFilt.html#7e4bab1036ea1bda1dbc2f9afc802706">nkeys</a> ; ++i) {
<a name="l01226"></a>01226         
<a name="l01227"></a>01227     <span class="keywordtype">int</span> x = f-&gt; keys [i] .ix ;
<a name="l01228"></a>01228     <span class="keywordtype">int</span> y = f-&gt; keys [i] .iy ;
<a name="l01229"></a>01229     <span class="keywordtype">int</span> s = f-&gt; keys [i]. is ;
<a name="l01230"></a>01230     
<a name="l01231"></a>01231     <span class="keywordtype">double</span> Dx=0,Dy=0,Ds=0,Dxx=0,Dyy=0,Dss=0,Dxy=0,Dxs=0,Dys=0 ;
<a name="l01232"></a>01232     <span class="keywordtype">double</span> A [3*3], b [3] ;
<a name="l01233"></a>01233     
<a name="l01234"></a>01234     <span class="keywordtype">int</span> dx = 0 ;
<a name="l01235"></a>01235     <span class="keywordtype">int</span> dy = 0 ;
<a name="l01236"></a>01236     
<a name="l01237"></a>01237     <span class="keywordtype">int</span> iter, i, j ;
<a name="l01238"></a>01238     
<a name="l01239"></a>01239     <span class="keywordflow">for</span> (iter = 0 ; iter &lt; 5 ; ++iter) {
<a name="l01240"></a>01240       
<a name="l01241"></a>01241       x += dx ;
<a name="l01242"></a>01242       y += dy ;
<a name="l01243"></a>01243       
<a name="l01244"></a>01244       pt = dog 
<a name="l01245"></a>01245         + xo * x
<a name="l01246"></a>01246         + yo * y
<a name="l01247"></a>01247         + so * (s - s_min) ;
<a name="l01248"></a>01248 
<a name="l01250"></a>01250 <span class="preprocessor">#define at(dx,dy,ds) (*( pt + (dx)*xo + (dy)*yo + (ds)*so))</span>
<a name="l01251"></a>01251 <span class="preprocessor"></span>
<a name="l01253"></a>01253 <span class="preprocessor">#define Aat(i,j)     (A[(i)+(j)*3])    </span>
<a name="l01254"></a>01254 <span class="preprocessor"></span>      
<a name="l01255"></a>01255       <span class="comment">/* compute the gradient */</span>
<a name="l01256"></a>01256       Dx = 0.5 * (at(+1,0,0) - at(-1,0,0)) ;
<a name="l01257"></a>01257       Dy = 0.5 * (at(0,+1,0) - at(0,-1,0));
<a name="l01258"></a>01258       Ds = 0.5 * (at(0,0,+1) - at(0,0,-1)) ;
<a name="l01259"></a>01259       
<a name="l01260"></a>01260       <span class="comment">/* compute the Hessian */</span>
<a name="l01261"></a>01261       Dxx = (at(+1,0,0) + at(-1,0,0) - 2.0 * at(0,0,0)) ;
<a name="l01262"></a>01262       Dyy = (at(0,+1,0) + at(0,-1,0) - 2.0 * at(0,0,0)) ;
<a name="l01263"></a>01263       Dss = (at(0,0,+1) + at(0,0,-1) - 2.0 * at(0,0,0)) ;
<a name="l01264"></a>01264       
<a name="l01265"></a>01265       Dxy = 0.25 * ( at(+1,+1,0) + at(-1,-1,0) - at(-1,+1,0) - at(+1,-1,0) ) ;
<a name="l01266"></a>01266       Dxs = 0.25 * ( at(+1,0,+1) + at(-1,0,-1) - at(-1,0,+1) - at(+1,0,-1) ) ;
<a name="l01267"></a>01267       Dys = 0.25 * ( at(0,+1,+1) + at(0,-1,-1) - at(0,-1,+1) - at(0,+1,-1) ) ;
<a name="l01268"></a>01268       
<a name="l01269"></a>01269       <span class="comment">/* solve linear system ....................................... */</span>
<a name="l01270"></a>01270       Aat(0,0) = Dxx ;
<a name="l01271"></a>01271       Aat(1,1) = Dyy ;
<a name="l01272"></a>01272       Aat(2,2) = Dss ;
<a name="l01273"></a>01273       Aat(0,1) = Aat(1,0) = Dxy ;
<a name="l01274"></a>01274       Aat(0,2) = Aat(2,0) = Dxs ;
<a name="l01275"></a>01275       Aat(1,2) = Aat(2,1) = Dys ;
<a name="l01276"></a>01276       
<a name="l01277"></a>01277       b[0] = - Dx ;
<a name="l01278"></a>01278       b[1] = - Dy ;
<a name="l01279"></a>01279       b[2] = - Ds ;
<a name="l01280"></a>01280       
<a name="l01281"></a>01281       <span class="comment">/* Gauss elimination */</span>
<a name="l01282"></a>01282       <span class="keywordflow">for</span>(j = 0 ; j &lt; 3 ; ++j) {        
<a name="l01283"></a>01283         <span class="keywordtype">double</span> maxa    = 0 ;
<a name="l01284"></a>01284         <span class="keywordtype">double</span> maxabsa = 0 ;
<a name="l01285"></a>01285         <span class="keywordtype">int</span>    maxi    = -1 ;
<a name="l01286"></a>01286         <span class="keywordtype">double</span> tmp ;
<a name="l01287"></a>01287         
<a name="l01288"></a>01288         <span class="comment">/* look for the maximally stable pivot */</span>
<a name="l01289"></a>01289         <span class="keywordflow">for</span> (i = j ; i &lt; 3 ; ++i) {
<a name="l01290"></a>01290           <span class="keywordtype">double</span> a    = Aat (i,j) ;
<a name="l01291"></a>01291           <span class="keywordtype">double</span> absa = <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (a) ;
<a name="l01292"></a>01292           <span class="keywordflow">if</span> (absa &gt; maxabsa) {
<a name="l01293"></a>01293             maxa    = a ;
<a name="l01294"></a>01294             maxabsa = absa ;
<a name="l01295"></a>01295             maxi    = i ;
<a name="l01296"></a>01296           }
<a name="l01297"></a>01297         }
<a name="l01298"></a>01298         
<a name="l01299"></a>01299         <span class="comment">/* if singular give up */</span>
<a name="l01300"></a>01300         <span class="keywordflow">if</span> (maxabsa &lt; 1e-10f) {
<a name="l01301"></a>01301           b[0] = 0 ;
<a name="l01302"></a>01302           b[1] = 0 ;
<a name="l01303"></a>01303           b[2] = 0 ;
<a name="l01304"></a>01304           break ;
<a name="l01305"></a>01305         }
<a name="l01306"></a>01306         
<a name="l01307"></a>01307         i = maxi ;
<a name="l01308"></a>01308         
<a name="l01309"></a>01309         <span class="comment">/* swap j-th row with i-th row and normalize j-th row */</span>
<a name="l01310"></a>01310         <span class="keywordflow">for</span>(jj = j ; jj &lt; 3 ; ++jj) {
<a name="l01311"></a>01311           tmp = Aat(i,jj) ; Aat(i,jj) = Aat(j,jj) ; Aat(j,jj) = tmp ;
<a name="l01312"></a>01312           Aat(j,jj) /= maxa ;
<a name="l01313"></a>01313         }
<a name="l01314"></a>01314         tmp = b[j] ; b[j] = b[i] ; b[i] = tmp ;
<a name="l01315"></a>01315         b[j] /= maxa ;
<a name="l01316"></a>01316         
<a name="l01317"></a>01317         <span class="comment">/* elimination */</span>
<a name="l01318"></a>01318         <span class="keywordflow">for</span> (ii = j+1 ; ii &lt; 3 ; ++ii) {
<a name="l01319"></a>01319           <span class="keywordtype">double</span> x = Aat(ii,j) ;
<a name="l01320"></a>01320           <span class="keywordflow">for</span> (jj = j ; jj &lt; 3 ; ++jj) {
<a name="l01321"></a>01321             Aat(ii,jj) -= x * Aat(j,jj) ;                
<a name="l01322"></a>01322           }
<a name="l01323"></a>01323           b[ii] -= x * b[j] ;
<a name="l01324"></a>01324         }
<a name="l01325"></a>01325       }
<a name="l01326"></a>01326       
<a name="l01327"></a>01327       <span class="comment">/* backward substitution */</span>
<a name="l01328"></a>01328       <span class="keywordflow">for</span> (i = 2 ; i &gt; 0 ; --i) {
<a name="l01329"></a>01329         <span class="keywordtype">double</span> x = b[i] ;
<a name="l01330"></a>01330         <span class="keywordflow">for</span> (ii = i-1 ; ii &gt;= 0 ; --ii) {
<a name="l01331"></a>01331           b[ii] -= x * Aat(ii,i) ;
<a name="l01332"></a>01332         }
<a name="l01333"></a>01333       }
<a name="l01334"></a>01334 
<a name="l01335"></a>01335       <span class="comment">/* .......................................................... */</span>      
<a name="l01336"></a>01336       <span class="comment">/* If the translation of the keypoint is big, move the keypoint</span>
<a name="l01337"></a>01337 <span class="comment">       * and re-iterate the computation. Otherwise we are all set.</span>
<a name="l01338"></a>01338 <span class="comment">       */</span>
<a name="l01339"></a>01339 
<a name="l01340"></a>01340       dx= ((b[0] &gt;  0.6 &amp;&amp; x &lt; w - 2) ?  1 : 0)
<a name="l01341"></a>01341         + ((b[0] &lt; -0.6 &amp;&amp; x &gt; 1    ) ? -1 : 0) ;
<a name="l01342"></a>01342       
<a name="l01343"></a>01343       dy= ((b[1] &gt;  0.6 &amp;&amp; y &lt; h - 2) ?  1 : 0)
<a name="l01344"></a>01344         + ((b[1] &lt; -0.6 &amp;&amp; y &gt; 1    ) ? -1 : 0) ;
<a name="l01345"></a>01345             
<a name="l01346"></a>01346       <span class="keywordflow">if</span> (dx == 0 &amp;&amp; dy == 0) break ;
<a name="l01347"></a>01347     }
<a name="l01348"></a>01348         
<a name="l01349"></a>01349     <span class="comment">/* check threshold and other conditions */</span>
<a name="l01350"></a>01350     {
<a name="l01351"></a>01351       <span class="keywordtype">double</span> val   = at(0,0,0) 
<a name="l01352"></a>01352         + 0.5 * (Dx * b[0] + Dy * b[1] + Ds * b[2]) ; 
<a name="l01353"></a>01353       <span class="keywordtype">double</span> score = (Dxx+Dyy)*(Dxx+Dyy) / (Dxx*Dyy - Dxy*Dxy) ; 
<a name="l01354"></a>01354       <span class="keywordtype">double</span> xn = x + b[0] ;
<a name="l01355"></a>01355       <span class="keywordtype">double</span> yn = y + b[1] ;
<a name="l01356"></a>01356       <span class="keywordtype">double</span> sn = s + b[2] ;
<a name="l01357"></a>01357 
<a name="l01358"></a>01358       <a class="code" href="host_8h.html#d32e7f8ec7333ff33998cf671a3b1412" title="Boolean.">vl_bool</a> good = 
<a name="l01359"></a>01359         <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (val)  &gt; tp                  &amp;&amp;
<a name="l01360"></a>01360         score           &lt; (te+1)*(te+1)/te    &amp;&amp;          
<a name="l01361"></a>01361         score           &gt;= 0                  &amp;&amp;
<a name="l01362"></a>01362         <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (b[0]) &lt;  1.5                &amp;&amp;         
<a name="l01363"></a>01363         <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (b[1]) &lt;  1.5                &amp;&amp;         
<a name="l01364"></a>01364         <a class="code" href="mathop_8h.html#b54b15a314843c27e7333e2fd05c0eb8" title="Fast abs(x).">vl_abs_d</a> (b[2]) &lt;  1.5                &amp;&amp;
<a name="l01365"></a>01365         xn              &gt;= 0                  &amp;&amp;         
<a name="l01366"></a>01366         xn              &lt;= w - 1              &amp;&amp;         
<a name="l01367"></a>01367         yn              &gt;= 0                  &amp;&amp;         
<a name="l01368"></a>01368         yn              &lt;= h - 1              &amp;&amp;         
<a name="l01369"></a>01369         sn              &gt;= s_min              &amp;&amp;     
<a name="l01370"></a>01370         sn              &lt;= s_max ;
<a name="l01371"></a>01371 
<a name="l01372"></a>01372       <span class="keywordflow">if</span> (good) {                       
<a name="l01373"></a>01373         k-&gt; o     = f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a> ;
<a name="l01374"></a>01374         k-&gt; ix    = x ;
<a name="l01375"></a>01375         k-&gt; iy    = y ;
<a name="l01376"></a>01376         k-&gt; is    = s ;
<a name="l01377"></a>01377         k-&gt; s     = sn ;
<a name="l01378"></a>01378         k-&gt; x     = xn * xper ;
<a name="l01379"></a>01379         k-&gt; y     = yn * xper ;
<a name="l01380"></a>01380         k-&gt; sigma = f-&gt;<a class="code" href="struct__VlSiftFilt.html#26c296dd10f53b29b32e40d73294bfc9">sigma0</a> * pow (2.0, sn/f-&gt;<a class="code" href="struct__VlSiftFilt.html#8531fa640678ec497e74d8fe4bfd18bd">S</a>) * xper ;        
<a name="l01381"></a>01381         ++ k ;
<a name="l01382"></a>01382       }
<a name="l01383"></a>01383 
<a name="l01384"></a>01384     } <span class="comment">/* done checking */</span>
<a name="l01385"></a>01385   } <span class="comment">/* next keypoint to refine */</span>
<a name="l01386"></a>01386 
<a name="l01387"></a>01387   <span class="comment">/* update keypoint count */</span>
<a name="l01388"></a>01388   f-&gt; nkeys = k - f-&gt;<a class="code" href="struct__VlSiftFilt.html#c7faf5e26c50f14c32be754b6b5432fc">keys</a> ;
<a name="l01389"></a>01389 }
<a name="l01390"></a>01390 
<a name="l01391"></a>01391 
<a name="l01404"></a>01404 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l01405"></a><a class="code" href="sift_8c.html#ce1fba61b0cc6ad7b1b0f9a07eabdf87">01405</a> <a class="code" href="sift_8c.html#ce1fba61b0cc6ad7b1b0f9a07eabdf87" title="Update gradients to current GSS octave.">update_gradient</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f)
<a name="l01406"></a>01406 { 
<a name="l01407"></a>01407   <span class="keywordtype">int</span>       s_min = f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> ;
<a name="l01408"></a>01408   <span class="keywordtype">int</span>       s_max = f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> ;
<a name="l01409"></a>01409   <span class="keywordtype">int</span>       w     = <a class="code" href="sift_8h.html#5d04844056daf18bdd9ad581e4f716eb" title="Get current octave width.">vl_sift_get_octave_width</a>  (f) ;
<a name="l01410"></a>01410   <span class="keywordtype">int</span>       h     = <a class="code" href="sift_8h.html#d5b6d41bea03ce9fef51ba477260cd7e" title="Get current octave height.">vl_sift_get_octave_height</a> (f) ;
<a name="l01411"></a>01411   <span class="keywordtype">int</span> <span class="keyword">const</span> xo    = 1 ;
<a name="l01412"></a>01412   <span class="keywordtype">int</span> <span class="keyword">const</span> yo    = w ;
<a name="l01413"></a>01413   <span class="keywordtype">int</span> <span class="keyword">const</span> so    = h * w ;
<a name="l01414"></a>01414   <span class="keywordtype">int</span> y, s ;
<a name="l01415"></a>01415 
<a name="l01416"></a>01416   <span class="keywordflow">if</span> (f-&gt;<a class="code" href="struct__VlSiftFilt.html#dc7ee960ea6e3cebb08edeb0d33becad">grad_o</a> == f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) return ;
<a name="l01417"></a>01417   
<a name="l01418"></a>01418   <span class="keywordflow">for</span> (s  = s_min + 1 ; 
<a name="l01419"></a>01419        s &lt;= s_max - 2 ; ++ s) {    
<a name="l01420"></a>01420 
<a name="l01421"></a>01421     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *src, *end, *grad, gx, gy ;
<a name="l01422"></a>01422 
<a name="l01423"></a>01423 <span class="preprocessor">#define SAVE_BACK                                                       \</span>
<a name="l01424"></a>01424 <span class="preprocessor">    *grad++ = vl_fast_sqrt_f (gx*gx + gy*gy) ;                          \</span>
<a name="l01425"></a>01425 <span class="preprocessor">    *grad++ = vl_mod_2pi_f   (vl_fast_atan2_f (gy, gx) + 2*VL_PI) ;     \</span>
<a name="l01426"></a>01426 <span class="preprocessor">    ++src ;                                                             \</span>
<a name="l01427"></a>01427 <span class="preprocessor">    </span>
<a name="l01428"></a>01428 <span class="preprocessor"></span>    src  = <a class="code" href="sift_8h.html#9cc1c77b8fc49875017557096539acb6" title="Get current octave data.">vl_sift_get_octave</a> (f,s) ;
<a name="l01429"></a>01429     grad = f-&gt;<a class="code" href="struct__VlSiftFilt.html#3dc6a5613163485ab9f0607b662af868">grad</a> + 2 * so * (s - s_min -1) ;
<a name="l01430"></a>01430     
<a name="l01431"></a>01431     <span class="comment">/* first pixel of the first row */</span>
<a name="l01432"></a>01432     gx = src[+xo] - src[0] ;
<a name="l01433"></a>01433     gy = src[+yo] - src[0] ;
<a name="l01434"></a>01434     SAVE_BACK ;
<a name="l01435"></a>01435 
<a name="l01436"></a>01436     <span class="comment">/* middle pixels of the  first row */</span>
<a name="l01437"></a>01437     end = (src - 1) + w - 1 ;
<a name="l01438"></a>01438     <span class="keywordflow">while</span> (src &lt; end) {
<a name="l01439"></a>01439       gx = 0.5 * (src[+xo] - src[-xo]) ;
<a name="l01440"></a>01440       gy =        src[+yo] - src[0] ;
<a name="l01441"></a>01441       SAVE_BACK ;
<a name="l01442"></a>01442     }
<a name="l01443"></a>01443     
<a name="l01444"></a>01444     <span class="comment">/* last pixel of the first row */</span>
<a name="l01445"></a>01445     gx = src[0]   - src[-xo] ;
<a name="l01446"></a>01446     gy = src[+yo] - src[0] ;
<a name="l01447"></a>01447     SAVE_BACK ;
<a name="l01448"></a>01448     
<a name="l01449"></a>01449     <span class="keywordflow">for</span> (y = 1 ; y &lt; h -1 ; ++y) {
<a name="l01450"></a>01450 
<a name="l01451"></a>01451       <span class="comment">/* first pixel of the middle rows */</span>
<a name="l01452"></a>01452       gx =        src[+xo] - src[0] ;
<a name="l01453"></a>01453       gy = 0.5 * (src[+yo] - src[-yo]) ;
<a name="l01454"></a>01454       SAVE_BACK ;
<a name="l01455"></a>01455 
<a name="l01456"></a>01456       <span class="comment">/* middle pixels of the middle rows */</span>
<a name="l01457"></a>01457       end = (src - 1) + w - 1 ;
<a name="l01458"></a>01458       <span class="keywordflow">while</span> (src &lt; end) {
<a name="l01459"></a>01459         gx = 0.5 * (src[+xo] - src[-xo]) ;
<a name="l01460"></a>01460         gy = 0.5 * (src[+yo] - src[-yo]) ;
<a name="l01461"></a>01461         SAVE_BACK ;
<a name="l01462"></a>01462       }
<a name="l01463"></a>01463       
<a name="l01464"></a>01464       <span class="comment">/* last pixel of the middle row */</span>
<a name="l01465"></a>01465       gx =        src[0]   - src[-xo] ;
<a name="l01466"></a>01466       gy = 0.5 * (src[+yo] - src[-yo]) ;
<a name="l01467"></a>01467       SAVE_BACK ;
<a name="l01468"></a>01468     }
<a name="l01469"></a>01469 
<a name="l01470"></a>01470     <span class="comment">/* first pixel of the last row */</span>
<a name="l01471"></a>01471     gx = src[+xo] - src[0] ;
<a name="l01472"></a>01472     gy = src[  0] - src[-yo] ;
<a name="l01473"></a>01473     SAVE_BACK ;
<a name="l01474"></a>01474     
<a name="l01475"></a>01475     <span class="comment">/* middle pixels of the last row */</span>
<a name="l01476"></a>01476     end = (src - 1) + w - 1 ;
<a name="l01477"></a>01477     <span class="keywordflow">while</span> (src &lt; end) {
<a name="l01478"></a>01478       gx = 0.5 * (src[+xo] - src[-xo]) ;
<a name="l01479"></a>01479       gy =        src[0]   - src[-yo] ;
<a name="l01480"></a>01480       SAVE_BACK ;
<a name="l01481"></a>01481     }
<a name="l01482"></a>01482     
<a name="l01483"></a>01483     <span class="comment">/* last pixel of the last row */</span>
<a name="l01484"></a>01484     gx = src[0]   - src[-xo] ;
<a name="l01485"></a>01485     gy = src[0]   - src[-yo] ;
<a name="l01486"></a>01486     SAVE_BACK ;
<a name="l01487"></a>01487   }  
<a name="l01488"></a>01488   f-&gt;<a class="code" href="struct__VlSiftFilt.html#dc7ee960ea6e3cebb08edeb0d33becad">grad_o</a> = f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a> ;
<a name="l01489"></a>01489 }
<a name="l01490"></a>01490 
<a name="l01515"></a>01515 VL_EXPORT
<a name="l01516"></a>01516 <span class="keywordtype">int</span>
<a name="l01517"></a><a class="code" href="sift_8h.html#b38b0a5d98e491762041e7378355b7b6">01517</a> <a class="code" href="sift_8c.html#b38b0a5d98e491762041e7378355b7b6" title="Calculate the keypoint orientation(s).">vl_sift_calc_keypoint_orientations</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f, 
<a name="l01518"></a>01518                                     <span class="keywordtype">double</span> angles [4],
<a name="l01519"></a>01519                                     <a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a> <span class="keyword">const</span> *k)
<a name="l01520"></a>01520 {
<a name="l01521"></a>01521   <span class="keywordtype">double</span> <span class="keyword">const</span> winf   = 1.5 ;
<a name="l01522"></a>01522   <span class="keywordtype">double</span>       xper   = pow (2.0, f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01523"></a>01523 
<a name="l01524"></a>01524   <span class="keywordtype">int</span>          w      = f-&gt; octave_width ;
<a name="l01525"></a>01525   <span class="keywordtype">int</span>          h      = f-&gt; octave_height ;
<a name="l01526"></a>01526   <span class="keywordtype">int</span> <span class="keyword">const</span>    xo     = 2 ;         <span class="comment">/* x-stride */</span>
<a name="l01527"></a>01527   <span class="keywordtype">int</span> <span class="keyword">const</span>    yo     = 2 * w ;     <span class="comment">/* y-stride */</span>
<a name="l01528"></a>01528   <span class="keywordtype">int</span> <span class="keyword">const</span>    so     = 2 * w * h ; <span class="comment">/* s-stride */</span>
<a name="l01529"></a>01529   <span class="keywordtype">double</span>       x      = k-&gt; x     / xper ;
<a name="l01530"></a>01530   <span class="keywordtype">double</span>       y      = k-&gt; y     / xper ;
<a name="l01531"></a>01531   <span class="keywordtype">double</span>       sigma  = k-&gt; sigma / xper ;
<a name="l01532"></a>01532 
<a name="l01533"></a>01533   <span class="keywordtype">int</span>          xi     = (int) (x + 0.5) ; 
<a name="l01534"></a>01534   <span class="keywordtype">int</span>          yi     = (int) (y + 0.5) ;
<a name="l01535"></a>01535   <span class="keywordtype">int</span>          si     = k-&gt; is ;
<a name="l01536"></a>01536 
<a name="l01537"></a>01537   <span class="keywordtype">double</span> <span class="keyword">const</span> sigmaw = winf * sigma ;
<a name="l01538"></a>01538   <span class="keywordtype">int</span>          W      = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(floor (3.0 * sigmaw), 1) ;
<a name="l01539"></a>01539 
<a name="l01540"></a>01540   <span class="keywordtype">int</span>          nangles= 0 ;
<a name="l01541"></a>01541 
<a name="l01542"></a>01542   <span class="keyword">enum</span> {nbins = 36} ;
<a name="l01543"></a>01543 
<a name="l01544"></a>01544   <span class="keywordtype">double</span> hist [nbins], maxh ;
<a name="l01545"></a>01545   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> * pt ;
<a name="l01546"></a>01546   <span class="keywordtype">int</span> xs, ys, iter, i ;
<a name="l01547"></a>01547   
<a name="l01548"></a>01548   <span class="comment">/* skip if the keypoint octave is not current */</span>
<a name="l01549"></a>01549   <span class="keywordflow">if</span>(k-&gt;<a class="code" href="struct__VlSiftKeypoint.html#c50bd6df4c02dc9a8328182138bdfd96">o</a> != f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>)
<a name="l01550"></a>01550     <span class="keywordflow">return</span> 0 ;
<a name="l01551"></a>01551   
<a name="l01552"></a>01552   <span class="comment">/* skip the keypoint if it is out of bounds */</span>
<a name="l01553"></a>01553   <span class="keywordflow">if</span>(xi &lt; 0            || 
<a name="l01554"></a>01554      xi &gt; w - 1        || 
<a name="l01555"></a>01555      yi &lt; 0            || 
<a name="l01556"></a>01556      yi &gt; h - 1        || 
<a name="l01557"></a>01557      si &lt; f-&gt;s_min + 1 || 
<a name="l01558"></a>01558      si &gt; f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - 2  ) {
<a name="l01559"></a>01559     <span class="keywordflow">return</span> 0 ;
<a name="l01560"></a>01560   }
<a name="l01561"></a>01561   
<a name="l01562"></a>01562   <span class="comment">/* make gradient up to date */</span>
<a name="l01563"></a>01563   <a class="code" href="sift_8c.html#ce1fba61b0cc6ad7b1b0f9a07eabdf87" title="Update gradients to current GSS octave.">update_gradient</a> (f) ;
<a name="l01564"></a>01564 
<a name="l01565"></a>01565   <span class="comment">/* clear histogram */</span>
<a name="l01566"></a>01566   memset (hist, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * nbins) ;
<a name="l01567"></a>01567   
<a name="l01568"></a>01568   <span class="comment">/* compute orientation histogram */</span>
<a name="l01569"></a>01569   pt = f-&gt; grad + xo*xi + yo*yi + so*(si - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> - 1) ;
<a name="l01570"></a>01570 
<a name="l01571"></a>01571 <span class="preprocessor">#undef  at</span>
<a name="l01572"></a>01572 <span class="preprocessor"></span><span class="preprocessor">#define at(dx,dy) (*(pt + xo * (dx) + yo * (dy)))</span>
<a name="l01573"></a>01573 <span class="preprocessor"></span>
<a name="l01574"></a>01574   <span class="keywordflow">for</span>(ys  =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (- W,       - yi) ; 
<a name="l01575"></a>01575       ys &lt;=  <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (+ W, h - 1 - yi) ; ++ys) {
<a name="l01576"></a>01576     
<a name="l01577"></a>01577     <span class="keywordflow">for</span>(xs  = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (- W,       - xi) ; 
<a name="l01578"></a>01578         xs &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (+ W, w - 1 - xi) ; ++xs) {
<a name="l01579"></a>01579 
<a name="l01580"></a>01580       
<a name="l01581"></a>01581       <span class="keywordtype">double</span> dx = (double)(xi + xs) - x;
<a name="l01582"></a>01582       <span class="keywordtype">double</span> dy = (double)(yi + ys) - y;
<a name="l01583"></a>01583       <span class="keywordtype">double</span> r2 = dx*dx + dy*dy ;
<a name="l01584"></a>01584       <span class="keywordtype">double</span> wgt, mod, ang, fbin ;
<a name="l01585"></a>01585 
<a name="l01586"></a>01586       <span class="comment">/* limit to a circular window */</span>
<a name="l01587"></a>01587       <span class="keywordflow">if</span> (r2 &gt;= W*W + 0.6) continue ;
<a name="l01588"></a>01588 
<a name="l01589"></a>01589       wgt  = <a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f" title="Fast  approximation.">fast_expn</a> (r2 / (2*sigmaw*sigmaw)) ;
<a name="l01590"></a>01590       mod  = *(pt + xs*xo + ys*yo    ) ;
<a name="l01591"></a>01591       ang  = *(pt + xs*xo + ys*yo + 1) ;
<a name="l01592"></a>01592       fbin = nbins * ang / (2 * <a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a>) ;
<a name="l01593"></a>01593        
<a name="l01594"></a>01594 <span class="preprocessor">#if defined(VL_SIFT_BILINEAR_ORIENTATIONS)</span>
<a name="l01595"></a>01595 <span class="preprocessor"></span>      {
<a name="l01596"></a>01596         <span class="keywordtype">int</span>    bin  = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (fbin - 0.5) ;
<a name="l01597"></a>01597         <span class="keywordtype">double</span> rbin = fbin - bin - 0.5 ;
<a name="l01598"></a>01598         hist [(bin + nbins) % nbins] += (1 - rbin) * mod * wgt ;
<a name="l01599"></a>01599         hist [(bin + 1    ) % nbins] += (    rbin) * mod * wgt ;
<a name="l01600"></a>01600       }
<a name="l01601"></a>01601 <span class="preprocessor">#else</span>
<a name="l01602"></a>01602 <span class="preprocessor"></span>      {
<a name="l01603"></a>01603         <span class="keywordtype">int</span>    bin  = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (fbin) ;
<a name="l01604"></a>01604         bin = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (nbins * ang / (2*<a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a>)) ;
<a name="l01605"></a>01605         hist [(bin) % nbins] += mod * wgt ;        
<a name="l01606"></a>01606       }
<a name="l01607"></a>01607 <span class="preprocessor">#endif</span>
<a name="l01608"></a>01608 <span class="preprocessor"></span>      
<a name="l01609"></a>01609     } <span class="comment">/* for xs */</span>
<a name="l01610"></a>01610   } <span class="comment">/* for ys */</span>
<a name="l01611"></a>01611 
<a name="l01612"></a>01612   <span class="comment">/* smooth histogram */</span>
<a name="l01613"></a>01613   <span class="keywordflow">for</span> (iter = 0; iter &lt; 6; iter ++) {
<a name="l01614"></a>01614     <span class="keywordtype">double</span> prev  = hist [nbins - 1] ;
<a name="l01615"></a>01615     <span class="keywordtype">double</span> first = hist [0] ;
<a name="l01616"></a>01616     <span class="keywordtype">int</span> i ;
<a name="l01617"></a>01617     <span class="keywordflow">for</span> (i = 0; i &lt; nbins - 1; i++) {
<a name="l01618"></a>01618       <span class="keywordtype">double</span> newh = (prev + hist[i] + hist[(i+1) % nbins]) / 3.0;
<a name="l01619"></a>01619       prev = hist[i] ;
<a name="l01620"></a>01620       hist[i] = newh ;
<a name="l01621"></a>01621     }
<a name="l01622"></a>01622     hist[i] = (prev + hist[i] + first) / 3.0 ;
<a name="l01623"></a>01623   }
<a name="l01624"></a>01624   
<a name="l01625"></a>01625   <span class="comment">/* find the histogram maximum */</span>
<a name="l01626"></a>01626   maxh = 0 ;
<a name="l01627"></a>01627   <span class="keywordflow">for</span> (i = 0 ; i &lt; nbins ; ++i) 
<a name="l01628"></a>01628     maxh = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (maxh, hist [i]) ;
<a name="l01629"></a>01629 
<a name="l01630"></a>01630   <span class="comment">/* find peaks within 80% from max */</span>
<a name="l01631"></a>01631   nangles = 0 ;
<a name="l01632"></a>01632   <span class="keywordflow">for</span>(i = 0 ; i &lt; nbins ; ++i) {
<a name="l01633"></a>01633     <span class="keywordtype">double</span> h0 = hist [i] ;
<a name="l01634"></a>01634     <span class="keywordtype">double</span> hm = hist [(i - 1 + nbins) % nbins] ;
<a name="l01635"></a>01635     <span class="keywordtype">double</span> hp = hist [(i + 1 + nbins) % nbins] ;
<a name="l01636"></a>01636     
<a name="l01637"></a>01637     <span class="comment">/* is this a peak? */</span>
<a name="l01638"></a>01638     <span class="keywordflow">if</span> (h0 &gt; 0.8*maxh &amp;&amp; h0 &gt; hm &amp;&amp; h0 &gt; hp) {
<a name="l01639"></a>01639       
<a name="l01640"></a>01640       <span class="comment">/* quadratic interpolation */</span>
<a name="l01641"></a>01641       <span class="keywordtype">double</span> di = - 0.5 * (hp - hm) / (hp + hm - 2 * h0) ; 
<a name="l01642"></a>01642       <span class="keywordtype">double</span> th = 2 * <a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a> * (i + di + 0.5) / nbins ;      
<a name="l01643"></a>01643       angles [ nangles++ ] = th ;
<a name="l01644"></a>01644       <span class="keywordflow">if</span>( nangles == 4 )
<a name="l01645"></a>01645         <span class="keywordflow">goto</span> enough_angles ;
<a name="l01646"></a>01646     }
<a name="l01647"></a>01647   }
<a name="l01648"></a>01648  enough_angles:
<a name="l01649"></a>01649   <span class="keywordflow">return</span> nangles ;
<a name="l01650"></a>01650 }
<a name="l01651"></a>01651 
<a name="l01652"></a>01652 
<a name="l01660"></a>01660 VL_INLINE <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>
<a name="l01661"></a>01661 <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a> 
<a name="l01662"></a><a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996">01662</a> (<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *begin, <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *end)
<a name="l01663"></a>01663 {
<a name="l01664"></a>01664   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>* iter ;
<a name="l01665"></a>01665   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>  norm = 0.0 ;
<a name="l01666"></a>01666 
<a name="l01667"></a>01667   <span class="keywordflow">for</span> (iter = begin ; iter != end ; ++ iter)
<a name="l01668"></a>01668     norm += (*iter) * (*iter) ;
<a name="l01669"></a>01669 
<a name="l01670"></a>01670   norm = <a class="code" href="mathop_8h.html#fd17414c0bd6edce9280378201a24847" title="Fast sqrt approximation.">vl_fast_sqrt_f</a> (norm) + <a class="code" href="mathop_8h.html#8088f3da04d6bce27544adaa6da948ca" title="IEEE single precision epsilon (math constant).">VL_EPSILON_F</a> ;
<a name="l01671"></a>01671 
<a name="l01672"></a>01672   <span class="keywordflow">for</span> (iter = begin; iter != end ; ++ iter)
<a name="l01673"></a>01673     *iter /= norm ;
<a name="l01674"></a>01674 
<a name="l01675"></a>01675   <span class="keywordflow">return</span> norm;
<a name="l01676"></a>01676 }
<a name="l01677"></a>01677 
<a name="l01710"></a>01710 VL_EXPORT
<a name="l01711"></a>01711 <span class="keywordtype">void</span>               
<a name="l01712"></a><a class="code" href="sift_8h.html#3ddb5d720d7452b25aee72957ae17326">01712</a> <a class="code" href="sift_8c.html#3d537eb2a200c3c19e9a751178d1b9b5" title="Run the SIFT descriptor on raw data.">vl_sift_calc_raw_descriptor</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> <span class="keyword">const</span> *f,
<a name="l01713"></a>01713                              <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span>* grad,
<a name="l01714"></a>01714                              <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *descr,
<a name="l01715"></a>01715                              <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height,
<a name="l01716"></a>01716                              <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, 
<a name="l01717"></a>01717                              <span class="keywordtype">double</span> sigma,
<a name="l01718"></a>01718                              <span class="keywordtype">double</span> angle0)
<a name="l01719"></a>01719 {
<a name="l01720"></a>01720   <span class="keywordtype">double</span> <span class="keyword">const</span> magnif = f-&gt; magnif ;
<a name="l01721"></a>01721 
<a name="l01722"></a>01722   <span class="keywordtype">int</span>          w      = width ;
<a name="l01723"></a>01723   <span class="keywordtype">int</span>          h      = height ;
<a name="l01724"></a>01724   <span class="keywordtype">int</span> <span class="keyword">const</span>    xo     = 2 ;         <span class="comment">/* x-stride */</span>
<a name="l01725"></a>01725   <span class="keywordtype">int</span> <span class="keyword">const</span>    yo     = 2 * w ;     <span class="comment">/* y-stride */</span>
<a name="l01726"></a>01726   
<a name="l01727"></a>01727   <span class="keywordtype">int</span>          xi     = (int) (x + 0.5) ; 
<a name="l01728"></a>01728   <span class="keywordtype">int</span>          yi     = (int) (y + 0.5) ;
<a name="l01729"></a>01729   
<a name="l01730"></a>01730   <span class="keywordtype">double</span> <span class="keyword">const</span> st0    = sin (angle0) ;
<a name="l01731"></a>01731   <span class="keywordtype">double</span> <span class="keyword">const</span> ct0    = cos (angle0) ;
<a name="l01732"></a>01732   <span class="keywordtype">double</span> <span class="keyword">const</span> SBP    = magnif * sigma + <a class="code" href="mathop_8h.html#a2d957b08ce16011fc3827c270cd2664" title="IEEE double precision epsilon (math constant).">VL_EPSILON_D</a> ;
<a name="l01733"></a>01733   <span class="keywordtype">int</span>    <span class="keyword">const</span> W      = floor
<a name="l01734"></a>01734     (sqrt(2.0) * SBP * (NBP + 1) / 2.0 + 0.5) ;
<a name="l01735"></a>01735   
<a name="l01736"></a>01736   <span class="keywordtype">int</span> <span class="keyword">const</span> binto = 1 ;          <span class="comment">/* bin theta-stride */</span>
<a name="l01737"></a>01737   <span class="keywordtype">int</span> <span class="keyword">const</span> binyo = NBO * NBP ;  <span class="comment">/* bin y-stride */</span>
<a name="l01738"></a>01738   <span class="keywordtype">int</span> <span class="keyword">const</span> binxo = NBO ;        <span class="comment">/* bin x-stride */</span>
<a name="l01739"></a>01739   
<a name="l01740"></a>01740   <span class="keywordtype">int</span> bin, dxi, dyi ;
<a name="l01741"></a>01741   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *pt ; 
<a name="l01742"></a>01742   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>       *dpt ;
<a name="l01743"></a>01743   
<a name="l01744"></a>01744   <span class="comment">/* check bounds */</span>
<a name="l01745"></a>01745   <span class="keywordflow">if</span>(xi    &lt;  0               || 
<a name="l01746"></a>01746      xi    &gt;= w               || 
<a name="l01747"></a>01747      yi    &lt;  0               || 
<a name="l01748"></a>01748      yi    &gt;= h -    1        )
<a name="l01749"></a>01749     return ;
<a name="l01750"></a>01750   
<a name="l01751"></a>01751   <span class="comment">/* clear descriptor */</span>
<a name="l01752"></a>01752   memset (descr, 0, <span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * NBO*NBP*NBP) ;
<a name="l01753"></a>01753   
<a name="l01754"></a>01754   <span class="comment">/* Center the scale space and the descriptor on the current keypoint. </span>
<a name="l01755"></a>01755 <span class="comment">   * Note that dpt is pointing to the bin of center (SBP/2,SBP/2,0).</span>
<a name="l01756"></a>01756 <span class="comment">   */</span>
<a name="l01757"></a>01757   pt  = grad + xi*xo + yi*yo ;
<a name="l01758"></a>01758   dpt = descr + (NBP/2) * binyo + (NBP/2) * binxo ;
<a name="l01759"></a>01759 
<a name="l01760"></a>01760 <span class="preprocessor">#undef atd</span>
<a name="l01761"></a>01761 <span class="preprocessor"></span><span class="preprocessor">#define atd(dbinx,dbiny,dbint) *(dpt + (dbint)*binto + (dbiny)*binyo + (dbinx)*binxo)</span>
<a name="l01762"></a>01762 <span class="preprocessor"></span>  
<a name="l01763"></a>01763   <span class="comment">/*</span>
<a name="l01764"></a>01764 <span class="comment">   * Process pixels in the intersection of the image rectangle</span>
<a name="l01765"></a>01765 <span class="comment">   * (1,1)-(M-1,N-1) and the keypoint bounding box.</span>
<a name="l01766"></a>01766 <span class="comment">   */</span>
<a name="l01767"></a>01767   <span class="keywordflow">for</span>(dyi =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(- W,   - yi   ) ; 
<a name="l01768"></a>01768       dyi &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(+ W, h - yi -1) ; ++ dyi) {
<a name="l01769"></a>01769     
<a name="l01770"></a>01770     <span class="keywordflow">for</span>(dxi =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(- W,   - xi   ) ; 
<a name="l01771"></a>01771         dxi &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(+ W, w - xi -1) ; ++ dxi) {
<a name="l01772"></a>01772 
<a name="l01773"></a>01773       <span class="comment">/* retrieve */</span>
<a name="l01774"></a>01774       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> mod   = *( pt + dxi*xo + dyi*yo + 0 ) ;
<a name="l01775"></a>01775       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> angle = *( pt + dxi*xo + dyi*yo + 1 ) ;
<a name="l01776"></a>01776       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> theta = <a class="code" href="mathop_8h.html#779371154b6f6c1a0f9bf51ad9afcd07" title="Fast mod(x, 2 * VL_PI).">vl_mod_2pi_f</a> (angle - angle0) ;
<a name="l01777"></a>01777       
<a name="l01778"></a>01778       <span class="comment">/* fractional displacement */</span>
<a name="l01779"></a>01779       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> dx = xi + dxi - x;
<a name="l01780"></a>01780       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> dy = yi + dyi - y;
<a name="l01781"></a>01781       
<a name="l01782"></a>01782       <span class="comment">/* get the displacement normalized w.r.t. the keypoint</span>
<a name="l01783"></a>01783 <span class="comment">         orientation and extension */</span>
<a name="l01784"></a>01784       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> nx = ( ct0 * dx + st0 * dy) / SBP ;
<a name="l01785"></a>01785       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> ny = (-st0 * dx + ct0 * dy) / SBP ; 
<a name="l01786"></a>01786       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> nt = NBO * theta / (2 * <a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a>) ;
<a name="l01787"></a>01787       
<a name="l01788"></a>01788       <span class="comment">/* Get the Gaussian weight of the sample. The Gaussian window</span>
<a name="l01789"></a>01789 <span class="comment">       * has a standard deviation equal to NBP/2. Note that dx and dy</span>
<a name="l01790"></a>01790 <span class="comment">       * are in the normalized frame, so that -NBP/2 &lt;= dx &lt;=</span>
<a name="l01791"></a>01791 <span class="comment">       * NBP/2. */</span>
<a name="l01792"></a>01792       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> wsigma = f-&gt;<a class="code" href="struct__VlSiftFilt.html#5540e0aab7df5e5abfb58d3d07af844b">windowSize</a> ;
<a name="l01793"></a>01793       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> win = <a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f" title="Fast  approximation.">fast_expn</a> 
<a name="l01794"></a>01794         ((nx*nx + ny*ny)/(2.0 * wsigma * wsigma)) ;
<a name="l01795"></a>01795       
<a name="l01796"></a>01796       <span class="comment">/* The sample will be distributed in 8 adjacent bins.</span>
<a name="l01797"></a>01797 <span class="comment">         We start from the ``lower-left'' bin. */</span>
<a name="l01798"></a>01798       <span class="keywordtype">int</span>         binx = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (nx - 0.5) ;
<a name="l01799"></a>01799       <span class="keywordtype">int</span>         biny = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (ny - 0.5) ;
<a name="l01800"></a>01800       <span class="keywordtype">int</span>         bint = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (nt) ;
<a name="l01801"></a>01801       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbinx = nx - (binx + 0.5) ;
<a name="l01802"></a>01802       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbiny = ny - (biny + 0.5) ;
<a name="l01803"></a>01803       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbint = nt - bint ;
<a name="l01804"></a>01804       <span class="keywordtype">int</span>         dbinx ;
<a name="l01805"></a>01805       <span class="keywordtype">int</span>         dbiny ;
<a name="l01806"></a>01806       <span class="keywordtype">int</span>         dbint ;
<a name="l01807"></a>01807       
<a name="l01808"></a>01808       <span class="comment">/* Distribute the current sample into the 8 adjacent bins*/</span>
<a name="l01809"></a>01809       <span class="keywordflow">for</span>(dbinx = 0 ; dbinx &lt; 2 ; ++dbinx) {
<a name="l01810"></a>01810         <span class="keywordflow">for</span>(dbiny = 0 ; dbiny &lt; 2 ; ++dbiny) {
<a name="l01811"></a>01811           <span class="keywordflow">for</span>(dbint = 0 ; dbint &lt; 2 ; ++dbint) {
<a name="l01812"></a>01812             
<a name="l01813"></a>01813             <span class="keywordflow">if</span> (binx + dbinx &gt;= - (NBP/2) &amp;&amp;
<a name="l01814"></a>01814                 binx + dbinx &lt;    (NBP/2) &amp;&amp;
<a name="l01815"></a>01815                 biny + dbiny &gt;= - (NBP/2) &amp;&amp;
<a name="l01816"></a>01816                 biny + dbiny &lt;    (NBP/2) ) {
<a name="l01817"></a>01817               <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> weight = win 
<a name="l01818"></a>01818                 * mod 
<a name="l01819"></a>01819                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbinx - rbinx)
<a name="l01820"></a>01820                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbiny - rbiny)
<a name="l01821"></a>01821                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbint - rbint) ;
<a name="l01822"></a>01822               
<a name="l01823"></a>01823               atd(binx+dbinx, biny+dbiny, (bint+dbint) % NBO) += weight ;
<a name="l01824"></a>01824             }
<a name="l01825"></a>01825           }            
<a name="l01826"></a>01826         }
<a name="l01827"></a>01827       }
<a name="l01828"></a>01828     }  
<a name="l01829"></a>01829   }
<a name="l01830"></a>01830 
<a name="l01831"></a>01831   <span class="comment">/* Standard SIFT descriptors are normalized, truncated and normalized again */</span>
<a name="l01832"></a>01832   <span class="keywordflow">if</span>(1) {
<a name="l01833"></a>01833 
<a name="l01834"></a>01834     <span class="comment">/* normalize L2 norm */</span>
<a name="l01835"></a>01835     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> norm = <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a> (descr, descr + NBO*NBP*NBP) ;
<a name="l01836"></a>01836 
<a name="l01837"></a>01837     <span class="comment">/* </span>
<a name="l01838"></a>01838 <span class="comment">       Set the descriptor to zero if it is lower than our</span>
<a name="l01839"></a>01839 <span class="comment">       norm_threshold.  We divide by the number of samples in the</span>
<a name="l01840"></a>01840 <span class="comment">       descriptor region becasue the Gaussian window used in the</span>
<a name="l01841"></a>01841 <span class="comment">       calculation fo the descriptor is not normalized.</span>
<a name="l01842"></a>01842 <span class="comment">     */</span>
<a name="l01843"></a>01843     <span class="keywordtype">int</span> numSamples = 
<a name="l01844"></a>01844       (<a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(W, w - xi -1) - <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(-W, - xi) + 1) * 
<a name="l01845"></a>01845       (<a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(W, h - yi -1) - <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(-W, - yi) + 1) ;
<a name="l01846"></a>01846 
<a name="l01847"></a>01847     <span class="keywordflow">if</span>(f-&gt; norm_thresh &amp;&amp; norm &lt; f-&gt; norm_thresh * numSamples) {
<a name="l01848"></a>01848         <span class="keywordflow">for</span>(bin = 0; bin &lt; NBO*NBP*NBP ; ++ bin)
<a name="l01849"></a>01849             descr [bin] = 0;
<a name="l01850"></a>01850     }
<a name="l01851"></a>01851     <span class="keywordflow">else</span> {    
<a name="l01852"></a>01852       <span class="comment">/* truncate at 0.2. */</span>
<a name="l01853"></a>01853       <span class="keywordflow">for</span>(bin = 0; bin &lt; NBO*NBP*NBP ; ++ bin) {
<a name="l01854"></a>01854         <span class="keywordflow">if</span> (descr [bin] &gt; 0.2) descr [bin] = 0.2;
<a name="l01855"></a>01855       }
<a name="l01856"></a>01856       
<a name="l01857"></a>01857       <span class="comment">/* normalize again. */</span>
<a name="l01858"></a>01858       <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a> (descr, descr + NBO*NBP*NBP) ;
<a name="l01859"></a>01859     }
<a name="l01860"></a>01860   }
<a name="l01861"></a>01861 }
<a name="l01862"></a>01862 
<a name="l01879"></a>01879 VL_EXPORT
<a name="l01880"></a>01880 <span class="keywordtype">void</span>
<a name="l01881"></a><a class="code" href="sift_8h.html#8631e63443c1faa7069a4e8e885fd82d">01881</a> <a class="code" href="sift_8c.html#d5021ed313da8e8c2d0174f711df6b0e" title="Compute the descriptor of a keypoint.">vl_sift_calc_keypoint_descriptor</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> *f,
<a name="l01882"></a>01882                                   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> *descr,
<a name="l01883"></a>01883                                   <a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a> <span class="keyword">const</span>* k,
<a name="l01884"></a>01884                                   <span class="keywordtype">double</span> angle0)
<a name="l01885"></a>01885 {
<a name="l01886"></a>01886   <span class="comment">/* </span>
<a name="l01887"></a>01887 <span class="comment">     The SIFT descriptor is a three dimensional histogram of the</span>
<a name="l01888"></a>01888 <span class="comment">     position and orientation of the gradient.  There are NBP bins for</span>
<a name="l01889"></a>01889 <span class="comment">     each spatial dimension and NBO bins for the orientation dimension,</span>
<a name="l01890"></a>01890 <span class="comment">     for a total of NBP x NBP x NBO bins.</span>
<a name="l01891"></a>01891 <span class="comment">     </span>
<a name="l01892"></a>01892 <span class="comment">     The support of each spatial bin has an extension of SBP = 3sigma</span>
<a name="l01893"></a>01893 <span class="comment">     pixels, where sigma is the scale of the keypoint.  Thus all the</span>
<a name="l01894"></a>01894 <span class="comment">     bins together have a support SBP x NBP pixels wide. Since</span>
<a name="l01895"></a>01895 <span class="comment">     weighting and interpolation of pixel is used, the support extends</span>
<a name="l01896"></a>01896 <span class="comment">     by another half bin. Therefore, the support is a square window of</span>
<a name="l01897"></a>01897 <span class="comment">     SBP x (NBP + 1) pixels. Finally, since the patch can be</span>
<a name="l01898"></a>01898 <span class="comment">     arbitrarily rotated, we need to consider a window 2W += sqrt(2) x</span>
<a name="l01899"></a>01899 <span class="comment">     SBP x (NBP + 1) pixels wide.</span>
<a name="l01900"></a>01900 <span class="comment">  */</span>      
<a name="l01901"></a>01901   
<a name="l01902"></a>01902   <span class="keywordtype">double</span> <span class="keyword">const</span> magnif      = f-&gt; magnif ;
<a name="l01903"></a>01903 
<a name="l01904"></a>01904   <span class="keywordtype">double</span>       xper        = pow (2.0, f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>) ;
<a name="l01905"></a>01905 
<a name="l01906"></a>01906   <span class="keywordtype">int</span>          w           = f-&gt; octave_width ;
<a name="l01907"></a>01907   <span class="keywordtype">int</span>          h           = f-&gt; octave_height ;
<a name="l01908"></a>01908   <span class="keywordtype">int</span> <span class="keyword">const</span>    xo          = 2 ;         <span class="comment">/* x-stride */</span>
<a name="l01909"></a>01909   <span class="keywordtype">int</span> <span class="keyword">const</span>    yo          = 2 * w ;     <span class="comment">/* y-stride */</span>
<a name="l01910"></a>01910   <span class="keywordtype">int</span> <span class="keyword">const</span>    so          = 2 * w * h ; <span class="comment">/* s-stride */</span>
<a name="l01911"></a>01911   <span class="keywordtype">double</span>       x           = k-&gt; x     / xper ;
<a name="l01912"></a>01912   <span class="keywordtype">double</span>       y           = k-&gt; y     / xper ;
<a name="l01913"></a>01913   <span class="keywordtype">double</span>       sigma       = k-&gt; sigma / xper ;
<a name="l01914"></a>01914 
<a name="l01915"></a>01915   <span class="keywordtype">int</span>          xi          = (int) (x + 0.5) ; 
<a name="l01916"></a>01916   <span class="keywordtype">int</span>          yi          = (int) (y + 0.5) ;
<a name="l01917"></a>01917   <span class="keywordtype">int</span>          si          = k-&gt; is ;
<a name="l01918"></a>01918 
<a name="l01919"></a>01919   <span class="keywordtype">double</span> <span class="keyword">const</span> st0         = sin (angle0) ;
<a name="l01920"></a>01920   <span class="keywordtype">double</span> <span class="keyword">const</span> ct0         = cos (angle0) ;
<a name="l01921"></a>01921   <span class="keywordtype">double</span> <span class="keyword">const</span> SBP         = magnif * sigma ;
<a name="l01922"></a>01922   <span class="keywordtype">int</span>    <span class="keyword">const</span> W           = floor
<a name="l01923"></a>01923     (sqrt(2.0) * SBP * (NBP + 1) / 2.0 + 0.5) ;
<a name="l01924"></a>01924 
<a name="l01925"></a>01925   <span class="keywordtype">int</span> <span class="keyword">const</span> binto = 1 ;          <span class="comment">/* bin theta-stride */</span>
<a name="l01926"></a>01926   <span class="keywordtype">int</span> <span class="keyword">const</span> binyo = NBO * NBP ;  <span class="comment">/* bin y-stride */</span>
<a name="l01927"></a>01927   <span class="keywordtype">int</span> <span class="keyword">const</span> binxo = NBO ;        <span class="comment">/* bin x-stride */</span>
<a name="l01928"></a>01928 
<a name="l01929"></a>01929   <span class="keywordtype">int</span> bin, dxi, dyi ;
<a name="l01930"></a>01930   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> *pt ; 
<a name="l01931"></a>01931   <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>       *dpt ;
<a name="l01932"></a>01932   
<a name="l01933"></a>01933   <span class="comment">/* check bounds */</span>
<a name="l01934"></a>01934   <span class="keywordflow">if</span>(k-&gt;<a class="code" href="struct__VlSiftKeypoint.html#c50bd6df4c02dc9a8328182138bdfd96">o</a>  != f-&gt;<a class="code" href="struct__VlSiftFilt.html#659eceb11be00244e73533f80f4ef484">o_cur</a>        ||
<a name="l01935"></a>01935      xi    &lt;  0               || 
<a name="l01936"></a>01936      xi    &gt;= w               || 
<a name="l01937"></a>01937      yi    &lt;  0               || 
<a name="l01938"></a>01938      yi    &gt;= h -    1        ||
<a name="l01939"></a>01939      si    &lt;  f-&gt;s_min + 1    ||
<a name="l01940"></a>01940      si    &gt;  f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - 2     )
<a name="l01941"></a>01941     return ;
<a name="l01942"></a>01942   
<a name="l01943"></a>01943   <span class="comment">/* synchronize gradient buffer */</span>
<a name="l01944"></a>01944   <a class="code" href="sift_8c.html#ce1fba61b0cc6ad7b1b0f9a07eabdf87" title="Update gradients to current GSS octave.">update_gradient</a> (f) ;
<a name="l01945"></a>01945 
<a name="l01946"></a>01946   <span class="comment">/* VL_PRINTF("W = %d ; magnif = %g ; SBP = %g\n", W,magnif,SBP) ; */</span>
<a name="l01947"></a>01947 
<a name="l01948"></a>01948   <span class="comment">/* clear descriptor */</span>
<a name="l01949"></a>01949   memset (descr, 0, <span class="keyword">sizeof</span>(<a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a>) * NBO*NBP*NBP) ;
<a name="l01950"></a>01950 
<a name="l01951"></a>01951   <span class="comment">/* Center the scale space and the descriptor on the current keypoint. </span>
<a name="l01952"></a>01952 <span class="comment">   * Note that dpt is pointing to the bin of center (SBP/2,SBP/2,0).</span>
<a name="l01953"></a>01953 <span class="comment">   */</span>
<a name="l01954"></a>01954   pt  = f-&gt;<a class="code" href="struct__VlSiftFilt.html#3dc6a5613163485ab9f0607b662af868">grad</a> + xi*xo + yi*yo + (si - f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> - 1)*so ;
<a name="l01955"></a>01955   dpt = descr + (NBP/2) * binyo + (NBP/2) * binxo ;
<a name="l01956"></a>01956      
<a name="l01957"></a>01957 <span class="preprocessor">#undef atd</span>
<a name="l01958"></a>01958 <span class="preprocessor"></span><span class="preprocessor">#define atd(dbinx,dbiny,dbint) *(dpt + (dbint)*binto + (dbiny)*binyo + (dbinx)*binxo)</span>
<a name="l01959"></a>01959 <span class="preprocessor"></span>      
<a name="l01960"></a>01960   <span class="comment">/*</span>
<a name="l01961"></a>01961 <span class="comment">   * Process pixels in the intersection of the image rectangle</span>
<a name="l01962"></a>01962 <span class="comment">   * (1,1)-(M-1,N-1) and the keypoint bounding box.</span>
<a name="l01963"></a>01963 <span class="comment">   */</span>
<a name="l01964"></a>01964   <span class="keywordflow">for</span>(dyi =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (- W, 1 - yi    ) ; 
<a name="l01965"></a>01965       dyi &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (+ W, h - yi - 2) ; ++ dyi) {
<a name="l01966"></a>01966 
<a name="l01967"></a>01967     <span class="keywordflow">for</span>(dxi =  <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (- W, 1 - xi    ) ; 
<a name="l01968"></a>01968         dxi &lt;= <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (+ W, w - xi - 2) ; ++ dxi) {
<a name="l01969"></a>01969       
<a name="l01970"></a>01970       <span class="comment">/* retrieve */</span>
<a name="l01971"></a>01971       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> mod   = *( pt + dxi*xo + dyi*yo + 0 ) ;
<a name="l01972"></a>01972       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> angle = *( pt + dxi*xo + dyi*yo + 1 ) ;
<a name="l01973"></a>01973       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> theta = <a class="code" href="mathop_8h.html#779371154b6f6c1a0f9bf51ad9afcd07" title="Fast mod(x, 2 * VL_PI).">vl_mod_2pi_f</a> (angle - angle0) ;
<a name="l01974"></a>01974       
<a name="l01975"></a>01975       <span class="comment">/* fractional displacement */</span>
<a name="l01976"></a>01976       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> dx = xi + dxi - x;
<a name="l01977"></a>01977       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> dy = yi + dyi - y;
<a name="l01978"></a>01978       
<a name="l01979"></a>01979       <span class="comment">/* get the displacement normalized w.r.t. the keypoint</span>
<a name="l01980"></a>01980 <span class="comment">         orientation and extension */</span>
<a name="l01981"></a>01981       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> nx = ( ct0 * dx + st0 * dy) / SBP ;
<a name="l01982"></a>01982       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> ny = (-st0 * dx + ct0 * dy) / SBP ; 
<a name="l01983"></a>01983       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> nt = NBO * theta / (2 * <a class="code" href="mathop_8h.html#19d43a5e0c355df553ebe825208a4cc1" title="Pi (math constant).">VL_PI</a>) ;
<a name="l01984"></a>01984       
<a name="l01985"></a>01985       <span class="comment">/* Get the Gaussian weight of the sample. The Gaussian window</span>
<a name="l01986"></a>01986 <span class="comment">       * has a standard deviation equal to NBP/2. Note that dx and dy</span>
<a name="l01987"></a>01987 <span class="comment">       * are in the normalized frame, so that -NBP/2 &lt;= dx &lt;=</span>
<a name="l01988"></a>01988 <span class="comment">       * NBP/2. */</span>
<a name="l01989"></a>01989       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> <span class="keyword">const</span> wsigma = f-&gt;<a class="code" href="struct__VlSiftFilt.html#5540e0aab7df5e5abfb58d3d07af844b">windowSize</a> ;
<a name="l01990"></a>01990       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> win = <a class="code" href="sift_8c.html#54a28f7f095a58401a7917073f43866f" title="Fast  approximation.">fast_expn</a> 
<a name="l01991"></a>01991         ((nx*nx + ny*ny)/(2.0 * wsigma * wsigma)) ;
<a name="l01992"></a>01992       
<a name="l01993"></a>01993       <span class="comment">/* The sample will be distributed in 8 adjacent bins.</span>
<a name="l01994"></a>01994 <span class="comment">         We start from the ``lower-left'' bin. */</span>
<a name="l01995"></a>01995       <span class="keywordtype">int</span>         binx = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (nx - 0.5) ;
<a name="l01996"></a>01996       <span class="keywordtype">int</span>         biny = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (ny - 0.5) ;
<a name="l01997"></a>01997       <span class="keywordtype">int</span>         bint = <a class="code" href="mathop_8h.html#0a641bb83f3aa7db107a51f63a534b52" title="Fast (int) floor(x).">vl_floor_f</a> (nt) ;
<a name="l01998"></a>01998       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbinx = nx - (binx + 0.5) ;
<a name="l01999"></a>01999       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbiny = ny - (biny + 0.5) ;
<a name="l02000"></a>02000       <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> rbint = nt - bint ;
<a name="l02001"></a>02001       <span class="keywordtype">int</span>         dbinx ;
<a name="l02002"></a>02002       <span class="keywordtype">int</span>         dbiny ;
<a name="l02003"></a>02003       <span class="keywordtype">int</span>         dbint ;
<a name="l02004"></a>02004       
<a name="l02005"></a>02005       <span class="comment">/* Distribute the current sample into the 8 adjacent bins*/</span>
<a name="l02006"></a>02006       <span class="keywordflow">for</span>(dbinx = 0 ; dbinx &lt; 2 ; ++dbinx) {
<a name="l02007"></a>02007         <span class="keywordflow">for</span>(dbiny = 0 ; dbiny &lt; 2 ; ++dbiny) {
<a name="l02008"></a>02008           <span class="keywordflow">for</span>(dbint = 0 ; dbint &lt; 2 ; ++dbint) {
<a name="l02009"></a>02009             
<a name="l02010"></a>02010             <span class="keywordflow">if</span> (binx + dbinx &gt;= - (NBP/2) &amp;&amp;
<a name="l02011"></a>02011                 binx + dbinx &lt;    (NBP/2) &amp;&amp;
<a name="l02012"></a>02012                 biny + dbiny &gt;= - (NBP/2) &amp;&amp;
<a name="l02013"></a>02013                 biny + dbiny &lt;    (NBP/2) ) {
<a name="l02014"></a>02014               <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> weight = win 
<a name="l02015"></a>02015                 * mod 
<a name="l02016"></a>02016                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbinx - rbinx)
<a name="l02017"></a>02017                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbiny - rbiny)
<a name="l02018"></a>02018                 * <a class="code" href="mathop_8h.html#c661df89e4bbb2730b3b5a8d15713084" title="Fast abs(x).">vl_abs_f</a> (1 - dbint - rbint) ;
<a name="l02019"></a>02019               
<a name="l02020"></a>02020               atd(binx+dbinx, biny+dbiny, (bint+dbint) % NBO) += weight ;
<a name="l02021"></a>02021             }
<a name="l02022"></a>02022           }            
<a name="l02023"></a>02023         }
<a name="l02024"></a>02024       }
<a name="l02025"></a>02025     }  
<a name="l02026"></a>02026   }
<a name="l02027"></a>02027 
<a name="l02028"></a>02028   <span class="comment">/* Standard SIFT descriptors are normalized, truncated and normalized again */</span>
<a name="l02029"></a>02029   <span class="keywordflow">if</span>(1) {
<a name="l02030"></a>02030 
<a name="l02031"></a>02031     <span class="comment">/* Normalize the histogram to L2 unit length. */</span>        
<a name="l02032"></a>02032     <a class="code" href="sift_8h.html#7efac4fb08e4642f12ef439ac376a5cc" title="SIFT filter pixel type.">vl_sift_pix</a> norm = <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a> (descr, descr + NBO*NBP*NBP) ;
<a name="l02033"></a>02033 
<a name="l02034"></a>02034     <span class="comment">/* Set the descriptor to zero if it is lower than our norm_threshold */</span>
<a name="l02035"></a>02035     <span class="keywordflow">if</span>(f-&gt; norm_thresh &amp;&amp; norm &lt; f-&gt; norm_thresh) {
<a name="l02036"></a>02036         <span class="keywordflow">for</span>(bin = 0; bin &lt; NBO*NBP*NBP ; ++ bin)
<a name="l02037"></a>02037             descr [bin] = 0;
<a name="l02038"></a>02038     }
<a name="l02039"></a>02039     <span class="keywordflow">else</span> {
<a name="l02040"></a>02040     
<a name="l02041"></a>02041       <span class="comment">/* Truncate at 0.2. */</span>
<a name="l02042"></a>02042       <span class="keywordflow">for</span>(bin = 0; bin &lt; NBO*NBP*NBP ; ++ bin) {
<a name="l02043"></a>02043         <span class="keywordflow">if</span> (descr [bin] &gt; 0.2) descr [bin] = 0.2;
<a name="l02044"></a>02044       }
<a name="l02045"></a>02045     
<a name="l02046"></a>02046       <span class="comment">/* Normalize again. */</span>
<a name="l02047"></a>02047       <a class="code" href="sift_8c.html#b7319c742b088d2629f388b714baa996" title="Normalizes in norm L_2 a descriptor.">normalize_histogram</a> (descr, descr + NBO*NBP*NBP) ;
<a name="l02048"></a>02048     }
<a name="l02049"></a>02049   }
<a name="l02050"></a>02050 
<a name="l02051"></a>02051 }
<a name="l02052"></a>02052 
<a name="l02066"></a>02066 VL_EXPORT
<a name="l02067"></a>02067 <span class="keywordtype">void</span>
<a name="l02068"></a><a class="code" href="sift_8h.html#445bbb5bcedabfa3c16df83d1817cd8d">02068</a> <a class="code" href="sift_8c.html#445bbb5bcedabfa3c16df83d1817cd8d" title="Initialize a keypoint from its position and scale.">vl_sift_keypoint_init</a> (<a class="code" href="struct__VlSiftFilt.html" title="SIFT filter.">VlSiftFilt</a> <span class="keyword">const</span> *f,
<a name="l02069"></a>02069                        <a class="code" href="struct__VlSiftKeypoint.html" title="SIFT filter keypoint.">VlSiftKeypoint</a> *k, 
<a name="l02070"></a>02070                        <span class="keywordtype">double</span> x,
<a name="l02071"></a>02071                        <span class="keywordtype">double</span> y,
<a name="l02072"></a>02072                        <span class="keywordtype">double</span> sigma)
<a name="l02073"></a>02073 {
<a name="l02074"></a>02074 
<a name="l02075"></a>02075   <span class="comment">/*</span>
<a name="l02076"></a>02076 <span class="comment">    The formula linking the keypoint scale sigma to the octave and</span>
<a name="l02077"></a>02077 <span class="comment">    scale index is</span>
<a name="l02078"></a>02078 <span class="comment"></span>
<a name="l02079"></a>02079 <span class="comment">    (1) sigma(o,s) = sigma0 2^(o+s/S)</span>
<a name="l02080"></a>02080 <span class="comment"></span>
<a name="l02081"></a>02081 <span class="comment">    for which</span>
<a name="l02082"></a>02082 <span class="comment">    </span>
<a name="l02083"></a>02083 <span class="comment">    (2) o + s/S = log2 sigma/sigma0 == phi.</span>
<a name="l02084"></a>02084 <span class="comment"></span>
<a name="l02085"></a>02085 <span class="comment">    In addition to the scale index s (which can be fractional due to</span>
<a name="l02086"></a>02086 <span class="comment">    scale interpolation) a keypoint has an integer scale index is too</span>
<a name="l02087"></a>02087 <span class="comment">    (which is the index of the scale level where it was detected in</span>
<a name="l02088"></a>02088 <span class="comment">    the DoG scale space). We have the constraints:</span>
<a name="l02089"></a>02089 <span class="comment"> </span>
<a name="l02090"></a>02090 <span class="comment">    - o and is are integer</span>
<a name="l02091"></a>02091 <span class="comment"></span>
<a name="l02092"></a>02092 <span class="comment">    - is is in the range [smin+1, smax-2  ]</span>
<a name="l02093"></a>02093 <span class="comment"></span>
<a name="l02094"></a>02094 <span class="comment">    - o  is in the range [omin,   omin+O-1]</span>
<a name="l02095"></a>02095 <span class="comment"></span>
<a name="l02096"></a>02096 <span class="comment">    - is = rand(s) most of the times (but not always, due to the way s</span>
<a name="l02097"></a>02097 <span class="comment">      is obtained by quadratic interpolation of the DoG scale space).</span>
<a name="l02098"></a>02098 <span class="comment"></span>
<a name="l02099"></a>02099 <span class="comment">    Depending on the values of smin and smax, often (2) has multiple</span>
<a name="l02100"></a>02100 <span class="comment">    solutions is,o that satisfy all constraints.  In this case we</span>
<a name="l02101"></a>02101 <span class="comment">    choose the one with biggest index o (this saves a bit of</span>
<a name="l02102"></a>02102 <span class="comment">    computation).</span>
<a name="l02103"></a>02103 <span class="comment"></span>
<a name="l02104"></a>02104 <span class="comment">    DETERMINING THE OCTAVE INDEX O</span>
<a name="l02105"></a>02105 <span class="comment"></span>
<a name="l02106"></a>02106 <span class="comment">    From (2) we have o = phi - s/S and we want to pick the biggest</span>
<a name="l02107"></a>02107 <span class="comment">    possible index o in the feasible range. This corresponds to</span>
<a name="l02108"></a>02108 <span class="comment">    selecting the smallest possible index s. We write s = is + ds</span>
<a name="l02109"></a>02109 <span class="comment">    where in most cases |ds|&lt;.5 (but in general |ds|&lt;1). So we have</span>
<a name="l02110"></a>02110 <span class="comment"></span>
<a name="l02111"></a>02111 <span class="comment">       o = phi - s/S,   s = is + ds ,   |ds| &lt; .5 (or |ds| &lt; 1).</span>
<a name="l02112"></a>02112 <span class="comment"></span>
<a name="l02113"></a>02113 <span class="comment">    Since is is in the range [smin+1,smax-2], s is in the range</span>
<a name="l02114"></a>02114 <span class="comment">    [smin+.5,smax-1.5] (or [smin,smax-1]), the number o is an integer</span>
<a name="l02115"></a>02115 <span class="comment">    in the range phi+[-smax+1.5,-smin-.5] (or</span>
<a name="l02116"></a>02116 <span class="comment">    phi+[-smax+1,-smin]). Thus the maximum value of o is obtained for</span>
<a name="l02117"></a>02117 <span class="comment">    o = floor(phi-smin-.5) (or o = floor(phi-smin)).</span>
<a name="l02118"></a>02118 <span class="comment"></span>
<a name="l02119"></a>02119 <span class="comment">    Finally o is clamped to make sure it is contained in the feasible</span>
<a name="l02120"></a>02120 <span class="comment">    range.</span>
<a name="l02121"></a>02121 <span class="comment"></span>
<a name="l02122"></a>02122 <span class="comment">    DETERMINING THE SCALE INDEXES S AND IS</span>
<a name="l02123"></a>02123 <span class="comment"></span>
<a name="l02124"></a>02124 <span class="comment">    Given o we can derive is by writing (2) as</span>
<a name="l02125"></a>02125 <span class="comment"></span>
<a name="l02126"></a>02126 <span class="comment">      s = is + ds = S(phi - o).</span>
<a name="l02127"></a>02127 <span class="comment"></span>
<a name="l02128"></a>02128 <span class="comment">    We then take is = round(s) and clamp its value to be in the</span>
<a name="l02129"></a>02129 <span class="comment">    feasible range.</span>
<a name="l02130"></a>02130 <span class="comment">  */</span>
<a name="l02131"></a>02131 
<a name="l02132"></a>02132   <span class="keywordtype">int</span>    o, ix, iy, is ;
<a name="l02133"></a>02133   <span class="keywordtype">double</span> s, phi, xper ;
<a name="l02134"></a>02134 
<a name="l02135"></a>02135   phi = log2 (sigma / f-&gt;<a class="code" href="struct__VlSiftFilt.html#26c296dd10f53b29b32e40d73294bfc9">sigma0</a>) ;
<a name="l02136"></a>02136   o   = <a class="code" href="mathop_8h.html#48bb7ee0a0b8f26c1ddcc8e9821f36ac" title="Fast (int) floor(x).">vl_floor_d</a> (phi -  ((<span class="keywordtype">double</span>) f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> + 0.5) / f-&gt;<a class="code" href="struct__VlSiftFilt.html#8531fa640678ec497e74d8fe4bfd18bd">S</a>) ;
<a name="l02137"></a>02137   o   = <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a> (o, f-&gt;<a class="code" href="struct__VlSiftFilt.html#9abcca743ed9482df03ccd9703909378">o_min</a> + f-&gt;<a class="code" href="struct__VlSiftFilt.html#e36d5a3c012a53484bbf7ef1a125e69e">O</a> - 1) ;
<a name="l02138"></a>02138   o   = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a> (o, f-&gt;<a class="code" href="struct__VlSiftFilt.html#9abcca743ed9482df03ccd9703909378">o_min</a>           ) ;
<a name="l02139"></a>02139   s   = f-&gt;<a class="code" href="struct__VlSiftFilt.html#8531fa640678ec497e74d8fe4bfd18bd">S</a> * (phi - o) ;
<a name="l02140"></a>02140 
<a name="l02141"></a>02141   is  = (int)(s + 0.5) ;
<a name="l02142"></a>02142   is  = <a class="code" href="generic_8h.html#36f2f85796040ca2f71bb34a9f55969f" title="Min operation.">VL_MIN</a>(is, f-&gt;<a class="code" href="struct__VlSiftFilt.html#51a63e5aa77dca58de4c025ff40f77ab">s_max</a> - 2) ;
<a name="l02143"></a>02143   is  = <a class="code" href="generic_8h.html#c8a3f4020a3e381daadd4214668dc63c" title="Max operation.">VL_MAX</a>(is, f-&gt;<a class="code" href="struct__VlSiftFilt.html#3631bdd696add103f8ebfe76750e9228">s_min</a> + 1) ;
<a name="l02144"></a>02144   
<a name="l02145"></a>02145   xper = pow (2.0, o) ;
<a name="l02146"></a>02146   ix   = (int)(x / xper + 0.5) ;
<a name="l02147"></a>02147   iy   = (int)(y / xper + 0.5) ;
<a name="l02148"></a>02148   
<a name="l02149"></a>02149   k -&gt; o  = o ;
<a name="l02150"></a>02150 
<a name="l02151"></a>02151   k -&gt; ix = ix ;
<a name="l02152"></a>02152   k -&gt; iy = iy ;
<a name="l02153"></a>02153   k -&gt; is = is ;
<a name="l02154"></a>02154 
<a name="l02155"></a>02155   k -&gt; x = x ;
<a name="l02156"></a>02156   k -&gt; y = y ;
<a name="l02157"></a>02157   k -&gt; s = s ;
<a name="l02158"></a>02158   
<a name="l02159"></a>02159   k-&gt;<a class="code" href="struct__VlSiftKeypoint.html#9a19aaa4aae25c5d94fd275df6ecdb7c">sigma</a> = sigma ;
<a name="l02160"></a>02160   
<a name="l02161"></a>02161   <span class="comment">/*</span>
<a name="l02162"></a>02162 <span class="comment">  VL_PRINTF ("k.ix     = %d\n", ix) ;</span>
<a name="l02163"></a>02163 <span class="comment">  VL_PRINTF ("k.iy     = %d\n", iy) ;</span>
<a name="l02164"></a>02164 <span class="comment">  VL_PRINTF ("k.is     = %d\n", is) ;</span>
<a name="l02165"></a>02165 <span class="comment">  VL_PRINTF ("k.o      = %d\n", o ) ;</span>
<a name="l02166"></a>02166 <span class="comment">  VL_PRINTF ("k.s      = %g\n", s ) ;</span>
<a name="l02167"></a>02167 <span class="comment">  VL_PRINTF ("k.x      = %g\n", x ) ;</span>
<a name="l02168"></a>02168 <span class="comment">  VL_PRINTF ("k.y      = %g\n", y ) ;</span>
<a name="l02169"></a>02169 <span class="comment">  VL_PRINTF ("k.sigma  = %g\n", sigma) ;</span>
<a name="l02170"></a>02170 <span class="comment">  */</span>
<a name="l02171"></a>02171 }
</pre></div></div>
    <!-- Doc Here -->
   </div>
  
   </div>
   <div class="clear">&nbsp;</div>
  </div> <!-- pagebody -->
  <div id="footer">
   &copy; 2005-09 Andrea Vedaldi and Brian Fulkerson
  </div> <!-- footer -->
  
  <!-- Google Analytics Begins -->
  <script xml:space="preserve" type="text/javascript">
   //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {
   var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
   document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
   }
   //]]>
  </script>
  <script xml:space="preserve" type="text/javascript">
    //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {

   try {
   var pageTracker = _gat._getTracker("UA-4936091-2");
   pageTracker._trackPageview();
   } catch(err) {}

   }
   //]]>
  </script>
  <!-- Google Analytics Ends -->
 </body>
</html>

 
