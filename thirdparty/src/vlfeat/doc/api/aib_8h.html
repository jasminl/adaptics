<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">   
 <meta>
  <!-- Stylesheets -->
  <link href="../web.css" type="text/css" rel="stylesheet"></link>
  <title>VLFeat - C API</title>
  
  
  <!-- Scripts-->
 
 </meta>
 
 <!-- Body Start -->
 <body>
  <div id="header">
   <!-- Google CSE Search Box Begins -->
   <form action=" http://www.vlfeat.org/search.html" method="get" id="cse-search-box" enctype="application/x-www-form-urlencoded">
    <div>
     <input type="hidden" name="cx" value="003215582122030917471:oq23albfeam"></input>
     <input type="hidden" name="cof" value="FORID:11"></input>
     <input type="hidden" name="ie" value="UTF-8"></input>
     <input type="text" name="q" size="31"></input>
     <input type="submit" name="sa" value="Search"></input>
    </div>
   </form>
   <script src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" xml:space="preserve" type="text/javascript"></script>
   <!-- Google CSE Search Box Ends -->
   <h1>VLFeat.org</h1>
  </div>
  <div id="headbanner">
  C API
  </div>
  <div id="pagebody">
   <div id="sidebar"> <!-- Navigation Start -->
   <ul>
<li><a href="../index.html">Home</a>
</li>
<li><a href="../download.html">Download</a>
</li>
<li><a href="index.html" class='active' >C API</a>
</li>
<li><a href="../mdoc/mdoc.html">Matlab API</a>
</li>
<li><a href="../man/man.html">Man pages</a>
</li>
<li><a href="../overview/tut.html">Tutorials</a>
</li>
</ul>

   </div> <!-- sidebar -->
   <div id="content">
   
   <div class="doxygen">
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>aib.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This provides an implementation of Agglomerative Information Bottleneck (AIB) as first described in:<p>
[Slonim] <em>N. Slonim and N. Tishby. Agglomerative information bottleneck. In Proc. NIPS, 1999</em><p>
AIB takes a discrete valued feature <img class="formulaInl" alt="$x$" src="form_0.png"> and a label <img class="formulaInl" alt="$c$" src="form_1.png"> and gradually compresses <img class="formulaInl" alt="$x$" src="form_0.png"> by iteratively merging values which minimize the loss in mutual information <img class="formulaInl" alt="$I(x,c)$" src="form_2.png">.<p>
While the algorithm is equivalent to the one described in [Slonim], it has some speedups that enable handling much larger datasets. Let <em>N</em> be the number of feature values and <em>C</em> the number of labels. The algorithm of [Slonim] is <img class="formulaInl" alt="$O(N^2)$" src="form_3.png"> in space and <img class="formulaInl" alt="$O(C N^3)$" src="form_4.png"> in time. This algorithm is <img class="formulaInl" alt="$O(N)$" src="form_5.png"> space and <img class="formulaInl" alt="$O(C N^2)$" src="form_6.png"> time in common cases (<img class="formulaInl" alt="$O(C N^3)$" src="form_4.png"> in the worst case).<h2><a class="anchor" name="aib-overview">
Overview</a></h2>
Given a discrete feature <img class="formulaInl" alt="$x \in \mathcal{X} = \{x_1,\dots,x_N\}$" src="form_7.png"> and a category label <img class="formulaInl" alt="$c = 1,\dots,C$" src="form_8.png"> with joint probability <img class="formulaInl" alt="$p(x,c)$" src="form_9.png">, AIB computes a compressed feature <img class="formulaInl" alt="$[x]_{ij}$" src="form_10.png"> by merging two values <img class="formulaInl" alt="$x_i$" src="form_11.png"> and <img class="formulaInl" alt="$x_j$" src="form_12.png">. Among all the pairs <img class="formulaInl" alt="$ij$" src="form_13.png">, AIB chooses the one that yields the smallest loss in the mutual information<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ D_{ij} = I(x,c) - I([x]_{ij},c) = \sum_c p(x_i) \log \frac{p(x_i,c)}{p(x_i)p(c)} + \sum_c p(x_i) \log \frac{p(x_i,c)}{p(x_i)p(c)} - \sum_c (p(x_i)+p(x_j)) \log \frac {p(x_i,c)+p(x_i,c)}{(p(x_i)+p(x_j))p(c)} \]" src="form_14.png">
<p>
<p>
AIB iterates this procedure until the desired level of compression is achieved.<h2><a class="anchor" name="aib-algorithm">
Algorithm details</a></h2>
Computing <img class="formulaInl" alt="$D_{ij}$" src="form_15.png"> requires <img class="formulaInl" alt="$O(C)$" src="form_16.png"> operations. For example, in standard AIB we need to calculate <p class="formulaDsp">
<img class="formulaDsp" alt="\[ D_{ij} = I(x,c) - I([x]_{ij},c) = \sum_c p(x_i) \log \frac{p(x_i,c)}{p(x_i)p(c)} + \sum_c p(x_i) \log \frac{p(x_i,c)}{p(x_i)p(c)} - \sum_c (p(x_i)+p(x_j)) \log \frac {p(x_i,c)+p(x_i,c)}{(p(x_i)+p(x_j))p(c)} \]" src="form_14.png">
<p>
<p>
Thus in a basic implementation of AIB, finding the optimal pair <img class="formulaInl" alt="$ij$" src="form_13.png"> of feature values requires <img class="formulaInl" alt="$O(CN^2)$" src="form_17.png"> operations in total. In order to join all the <img class="formulaInl" alt="$N$" src="form_18.png"> values, we repeat this procedure <img class="formulaInl" alt="$O(N)$" src="form_5.png"> times, yielding <img class="formulaInl" alt="$O(N^3 C)$" src="form_19.png"> time and <img class="formulaInl" alt="$O(1)$" src="form_20.png"> space complexity (this does not account for the space need to store the input).<p>
The complexity can be improved by reusing computations. For instance, we can store the matrix <img class="formulaInl" alt="$D = [ D_{ij} ]$" src="form_21.png"> (which requires <img class="formulaInl" alt="$O(N^2)$" src="form_3.png"> space). Then, after joining <img class="formulaInl" alt="$ij$" src="form_13.png">, all of the matrix <em>D</em> except the rows and columns (the matrix is symmetric) of indexes <em>i</em> and <em>j</em> is unchanged. These two rows and columns are deleted and a new row and column, whose computation requires <img class="formulaInl" alt="$O(NC)$" src="form_22.png"> operations, are added for the merged value <img class="formulaInl" alt="$x_{ij}$" src="form_23.png">. Finding the minimal element of the matrix still requires <img class="formulaInl" alt="$O(N^2)$" src="form_3.png"> operations, so the complexity of this algorithm is <img class="formulaInl" alt="$O(N^2C + N^3)$" src="form_24.png"> time and <img class="formulaInl" alt="$O(N^2)$" src="form_3.png"> space.<p>
We can obtain a much better expected complexity as follows. First, instead of storing the whole matrix <em>D</em>, we store the smallest element (index and value) of each row as <img class="formulaInl" alt="$(q_i, D_i)$" src="form_25.png"> (notice that this is also the best element of each column since <em>D</em> is symmetric). This requires <img class="formulaInl" alt="$O(N)$" src="form_5.png"> space and finding the minimal element of the matrix requires <img class="formulaInl" alt="$O(N)$" src="form_5.png"> operations. After joining <img class="formulaInl" alt="$ij$" src="form_13.png">, we have to efficiently update this representation. This is done as follows:<p>
<ul>
<li>The entries <img class="formulaInl" alt="$(q_i,D_i)$" src="form_26.png"> and <img class="formulaInl" alt="$(q_j,D_j)$" src="form_27.png"> are deleted.</li><li>A new entry <img class="formulaInl" alt="$(q_{ij},D_{ij})$" src="form_28.png"> for the joint value <img class="formulaInl" alt="$x_{ij}$" src="form_23.png"> is added. This requires <img class="formulaInl" alt="$O(CN)$" src="form_29.png"> operations.</li><li>We test which other entries <img class="formulaInl" alt="$(q_{k},D_{k})$" src="form_30.png"> need to be updated. Recall that <img class="formulaInl" alt="$(q_{k},D_{k})$" src="form_30.png"> means that, before the merge, the value closest to <img class="formulaInl" alt="$x_k$" src="form_31.png"> was <img class="formulaInl" alt="$x_{q_k}$" src="form_32.png"> at a distance <img class="formulaInl" alt="$D_k$" src="form_33.png">. Then<ul>
<li>If <img class="formulaInl" alt="$q_k \not = i$" src="form_34.png">, <img class="formulaInl" alt="$q_k \not = j$" src="form_35.png"> and <img class="formulaInl" alt="$D_{k,ij} \geq D_k$" src="form_36.png">, then <img class="formulaInl" alt="$q_k$" src="form_37.png"> is still the closest element and we do not do anything.</li><li>If <img class="formulaInl" alt="$q_k \not = i$" src="form_34.png">, <img class="formulaInl" alt="$q_k \not = j$" src="form_35.png"> and <img class="formulaInl" alt="$D_{k,ij} < D_k$" src="form_38.png">, then the closest element is <img class="formulaInl" alt="$ij$" src="form_13.png"> and we update the entry in constant time.</li><li>If <img class="formulaInl" alt="$q_k = i$" src="form_39.png"> or <img class="formulaInl" alt="$q_k = j$" src="form_40.png">, then we need to re-compute the closest element in <img class="formulaInl" alt="$O(CN)$" src="form_29.png"> operations.</li></ul>
</li></ul>
<p>
This algorithm requires only <img class="formulaInl" alt="$O(N)$" src="form_5.png"> space and <img class="formulaInl" alt="$O(\gamma(N) C N^2)$" src="form_41.png"> time, where <img class="formulaInl" alt="$\gamma(N)$" src="form_42.png"> is the expected number of times we fall in the last case. In common cases one has <img class="formulaInl" alt="$\gamma(N) \approx \mathrm{const.}$" src="form_43.png">, so the time saving is significant.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Brian Fulkerson <p>
Andrea Vedaldi </dd></dl>

<p>Definition in file <a class="el" href="aib_8h-source.html">aib.h</a>.</p>

<p>
<code>#include &quot;<a class="el" href="generic_8h-source.html">generic.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="mathop_8h-source.html">mathop.h</a>&quot;</code><br>

<p>
<a href="aib_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__VlAIB.html">_VlAIB</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">AIB algorithm data.  <a href="struct__VlAIB.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Create and destroy</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_EXPORT <a class="el" href="struct__VlAIB.html">VlAIB</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="aib_8h.html#51ae009a477fa6da30193567703dc908">vl_aib_new</a> (double *Pcx, <a class="el" href="host_8h.html#5bd6e91d6bfd0be04101fdca94069c92">vl_uint</a> nvalues, <a class="el" href="host_8h.html#5bd6e91d6bfd0be04101fdca94069c92">vl_uint</a> nlabels)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates and initializes the internal data structure.  <a href="#51ae009a477fa6da30193567703dc908"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="aib_8h.html#ef5b4ebd2cb6d4102014bf4a9032f678">vl_aib_delete</a> (<a class="el" href="struct__VlAIB.html">VlAIB</a> *aib)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes AIB data structure.  <a href="#ef5b4ebd2cb6d4102014bf4a9032f678"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Process data</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_EXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="aib_8h.html#9512d915c4b42026113274dacfab3df2">vl_aib_process</a> (<a class="el" href="struct__VlAIB.html">VlAIB</a> *aib)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Runs AIB on Pcx.  <a href="#9512d915c4b42026113274dacfab3df2"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Retrieve results</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE <a class="el" href="host_8h.html#5bd6e91d6bfd0be04101fdca94069c92">vl_uint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="aib_8h.html#bb1fae94a63c1b5b314a54a73db6132a">vl_aib_get_parents</a> (<a class="el" href="struct__VlAIB.html">VlAIB</a> const *aib)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get resulting list of parents.  <a href="#bb1fae94a63c1b5b314a54a73db6132a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VL_INLINE double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="aib_8h.html#0c19cfc121aa4eff6b4ccd58a2168d5c">vl_aib_get_costs</a> (<a class="el" href="struct__VlAIB.html">VlAIB</a> const *aib)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a list of merge costs.  <a href="#0c19cfc121aa4eff6b4ccd58a2168d5c"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ef5b4ebd2cb6d4102014bf4a9032f678"></a><!-- doxytag: member="aib.h::vl_aib_delete" ref="ef5b4ebd2cb6d4102014bf4a9032f678" args="(VlAIB *aib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_EXPORT void vl_aib_delete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__VlAIB.html">VlAIB</a> *&nbsp;</td>
          <td class="paramname"> <em>aib</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aib</em>&nbsp;</td><td>data structure to delete. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="aib_8c-source.html#l00528">528</a> of file <a class="el" href="aib_8c-source.html">aib.c</a>.</p>

<p>References <a class="el" href="generic_8h-source.html#l00249">vl_free()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0c19cfc121aa4eff6b4ccd58a2168d5c"></a><!-- doxytag: member="aib.h::vl_aib_get_costs" ref="0c19cfc121aa4eff6b4ccd58a2168d5c" args="(VlAIB const *aib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE double * vl_aib_get_costs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__VlAIB.html">VlAIB</a> const *&nbsp;</td>
          <td class="paramname"> <em>aib</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aib</em>&nbsp;</td><td>AIB filter. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An array of costs </dd></dl>

<p>Definition at line <a class="el" href="aib_8h-source.html#l00109">109</a> of file <a class="el" href="aib_8h-source.html">aib.h</a>.</p>

<p>References <a class="el" href="aib_8h-source.html#l00055">_VlAIB::costs</a>.</p>

</div>
</div><p>
<a class="anchor" name="bb1fae94a63c1b5b314a54a73db6132a"></a><!-- doxytag: member="aib.h::vl_aib_get_parents" ref="bb1fae94a63c1b5b314a54a73db6132a" args="(VlAIB const *aib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_INLINE <a class="el" href="host_8h.html#5bd6e91d6bfd0be04101fdca94069c92">vl_uint</a> * vl_aib_get_parents           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__VlAIB.html">VlAIB</a> const *&nbsp;</td>
          <td class="paramname"> <em>aib</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aib</em>&nbsp;</td><td>AIB filter. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An array of parents </dd></dl>

<p>Definition at line <a class="el" href="aib_8h-source.html#l00097">97</a> of file <a class="el" href="aib_8h-source.html">aib.h</a>.</p>

<p>References <a class="el" href="aib_8h-source.html#l00054">_VlAIB::parents</a>.</p>

</div>
</div><p>
<a class="anchor" name="51ae009a477fa6da30193567703dc908"></a><!-- doxytag: member="aib.h::vl_aib_new" ref="51ae009a477fa6da30193567703dc908" args="(double *Pcx, vl_uint nvalues, vl_uint nlabels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_EXPORT <a class="el" href="struct__VlAIB.html">VlAIB</a>* vl_aib_new           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>Pcx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#5bd6e91d6bfd0be04101fdca94069c92">vl_uint</a>&nbsp;</td>
          <td class="paramname"> <em>nvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#5bd6e91d6bfd0be04101fdca94069c92">vl_uint</a>&nbsp;</td>
          <td class="paramname"> <em>nlabels</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Pcx</em>&nbsp;</td><td>A pointer to a 2D array of probabilities </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvalues</em>&nbsp;</td><td>The number of rows in the array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nlabels</em>&nbsp;</td><td>The number of columns in the array</td></tr>
  </table>
</dl>
Creates a new <em>VlAIB</em> struct containing pointers to all the data that will be used during the AIB process.<p>
Allocates memory for the following:<ul>
<li>Px (nvalues*sizeof(double))</li><li>Pc (nlabels*sizeof(double))</li><li>nodelist (nvalues*sizeof(vl_uint))</li><li>which (nvalues*sizeof(vl_uint))</li><li>beta (nvalues*sizeof(double))</li><li>bidx (nvalues*sizeof(vl_uint))</li><li>parents ((2*nvalues-1)*sizeof(vl_uint))</li><li>costs (nvalues*sizeof(double))</li></ul>
<p>
Since it simply copies to pointer to Pcx, the total additional memory requirement is:<p>
(3*nvalues+nlabels)*sizeof(double) + 4*nvalues*sizeof(vl_uint)<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated and initialized <em>VlAIB</em> pointer </dd></dl>

<p>Definition at line <a class="el" href="aib_8c-source.html#l00484">484</a> of file <a class="el" href="aib_8c-source.html">aib.c</a>.</p>

<p>References <a class="el" href="aib_8h-source.html#l00041">_VlAIB::beta</a>, <a class="el" href="aib_8h-source.html#l00042">_VlAIB::bidx</a>, <a class="el" href="aib_8h-source.html#l00055">_VlAIB::costs</a>, <a class="el" href="aib_8h-source.html#l00040">_VlAIB::nentries</a>, <a class="el" href="aib_8h-source.html#l00052">_VlAIB::nlabels</a>, <a class="el" href="aib_8h-source.html#l00039">_VlAIB::nodes</a>, <a class="el" href="aib_8h-source.html#l00051">_VlAIB::nvalues</a>, <a class="el" href="aib_8h-source.html#l00046">_VlAIB::nwhich</a>, <a class="el" href="aib_8h-source.html#l00054">_VlAIB::parents</a>, <a class="el" href="aib_8h-source.html#l00050">_VlAIB::Pc</a>, <a class="el" href="aib_8h-source.html#l00048">_VlAIB::Pcx</a>, <a class="el" href="aib_8h-source.html#l00049">_VlAIB::Px</a>, <a class="el" href="aib_8c-source.html#l00153">vl_aib_new_nodelist()</a>, <a class="el" href="aib_8c-source.html#l00200">vl_aib_new_Pc()</a>, <a class="el" href="aib_8c-source.html#l00175">vl_aib_new_Px()</a>, <a class="el" href="aib_8c-source.html#l00134">vl_aib_normalize_P()</a>, <a class="el" href="generic_8h-source.html#l00231">vl_malloc()</a>, and <a class="el" href="aib_8h-source.html#l00045">_VlAIB::which</a>.</p>

</div>
</div><p>
<a class="anchor" name="9512d915c4b42026113274dacfab3df2"></a><!-- doxytag: member="aib.h::vl_aib_process" ref="9512d915c4b42026113274dacfab3df2" args="(VlAIB *aib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VL_EXPORT void vl_aib_process           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__VlAIB.html">VlAIB</a> *&nbsp;</td>
          <td class="paramname"> <em>aib</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aib</em>&nbsp;</td><td>AIB object to process</td></tr>
  </table>
</dl>
The function runs Agglomerative Information Bottleneck (AIB) on the joint probability table <em>aib-&gt;Pcx</em> which has labels along the columns and feature values along the rows. AIB iteratively merges the two values of the feature <code>x</code> that causes the smallest decrease in mutual information between the random variables <code>x</code> and <code>c</code>.<p>
Merge operations are arranged in a binary tree. The nodes of the tree correspond to the original feature values and any other value obtained as a result of a merge operation. The nodes are indexed in breadth-first order, starting from the leaves. The first index is zero. In this way, the leaves correspond directly to the original feature values. In total there are <code>2*nvalues-1</code> nodes.<p>
The results may be accessed through vl_aib_get_parents which returns an array with one element per tree node. Each element is the index the parent node. The root parent is equal to zero. The array has <code>2*nvalues-1</code> elements.<p>
Feature values with null probability are ignored by the algorithm and their nodes have parents indexing a non-existent tree node (a value bigger than <code>2*nvalues-1</code>).<p>
Then the function will also compute the information level after each merge. vl_get_costs will return a vector with the information level after each merge. <em>cost</em> has <code>nvalues</code> entries: The first is the value of the cost functional before any merge, and the others are the cost after the <code>nvalues-1</code> merges. 
<p>Definition at line <a class="el" href="aib_8c-source.html#l00582">582</a> of file <a class="el" href="aib_8c-source.html">aib.c</a>.</p>

<p>References <a class="el" href="aib_8h-source.html#l00055">_VlAIB::costs</a>, <a class="el" href="aib_8h-source.html#l00039">_VlAIB::nodes</a>, <a class="el" href="aib_8h-source.html#l00051">_VlAIB::nvalues</a>, <a class="el" href="aib_8h-source.html#l00046">_VlAIB::nwhich</a>, <a class="el" href="aib_8h-source.html#l00054">_VlAIB::parents</a>, <a class="el" href="aib_8c-source.html#l00432">vl_aib_calculate_information()</a>, <a class="el" href="aib_8c-source.html#l00267">vl_aib_merge_nodes()</a>, <a class="el" href="aib_8c-source.html#l00228">vl_aib_min_beta()</a>, <a class="el" href="aib_8c-source.html#l00346">vl_aib_update_beta()</a>, <a class="el" href="mathop_8h-source.html#l00083">VL_NAN_D</a>, and <a class="el" href="generic_8h-source.html#l00147">VL_PRINTF</a>.</p>

</div>
</div><p>
</div>
    <!-- Doc Here -->
   </div>
  
   </div>
   <div class="clear">&nbsp;</div>
  </div> <!-- pagebody -->
  <div id="footer">
   &copy; 2005-09 Andrea Vedaldi and Brian Fulkerson
  </div> <!-- footer -->
  
  <!-- Google Analytics Begins -->
  <script xml:space="preserve" type="text/javascript">
   //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {
   var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
   document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
   }
   //]]>
  </script>
  <script xml:space="preserve" type="text/javascript">
    //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {

   try {
   var pageTracker = _gat._getTracker("UA-4936091-2");
   pageTracker._trackPageview();
   } catch(err) {}

   }
   //]]>
  </script>
  <!-- Google Analytics Ends -->
 </body>
</html>

 
